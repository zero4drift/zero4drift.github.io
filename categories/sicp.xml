<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>钉钉是世界上最傻逼的app (Posts about SICP)</title><link>https://zero4drift.github.io/</link><description></description><atom:link href="https://zero4drift.github.io/categories/sicp.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2018 &lt;a href="mailto:fang0052@e.ntu.edu.sg"&gt;zero4drift&lt;/a&gt; </copyright><lastBuildDate>Thu, 13 Dec 2018 15:07:26 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>SICP-Refresher-Chapter-1</title><link>https://zero4drift.github.io/posts/sicp-refresher-chapter-1/</link><dc:creator>zero4drift</dc:creator><description>&lt;div id="outline-container-org4745aea" class="outline-2"&gt;
&lt;h2 id="org4745aea"&gt;写在前面&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org4745aea"&gt;
&lt;p&gt;
&lt;i&gt;SICP&lt;/i&gt; 整本书去年中旬就看完了，第一章到第四章的习题也已经全部解决，现在为什么
还要再来一遍？
&lt;/p&gt;

&lt;ol class="org-ol"&gt;
&lt;li&gt;说到习题，由于当时看这本书做习题时是在 windows 平台上，而 windows 系统并没
有现成的非常方便地运行 scheme 程序的工具 (例如 cmuscheme 用起来就很麻烦),
习题程序大部分都没有严格测试过，很多就是代码逻辑通顺就算完成，现在想来 bug
应该不少；&lt;/li&gt;
&lt;li&gt;第五章从基于寄存器机器的设计引出解释器和编译器的原理，虽然说此章太多的习题
是叙述题所以没有做，但是 scheme repl 解释器的 c/c++ 实现还是值得一做的；&lt;/li&gt;
&lt;li&gt;&lt;i&gt;SICP&lt;/i&gt; 的编程思想贯穿于今年学习 &lt;i&gt;Cpp-Primer&lt;/i&gt; 以及 &lt;i&gt;CLRS&lt;/i&gt; 的过程当中，这个我
很明确的感受到了：构造过程抽象 &amp;amp; 构造数据抽象，虽然我只能说是略有领会，但确
实在解决编程问题时提供了极大的帮助。编程工具会被淘汰，但编程思想永不过时，
特别是在实践之后再重温必有更多获益；&lt;/li&gt;
&lt;li&gt;&lt;i&gt;Cpp-Primer&lt;/i&gt; &amp;amp; &lt;i&gt;CLRS&lt;/i&gt; 在博客的相关博文中并没有详细的总结当时的代码思路，其
主要内容是代码及一小部分注释，注释部分或者是关于代码的难点，亦或者是提醒容
易出错的地方，这样的形式可读性很差，但要仔细组织文档的话，整体工作量又何止
增加一倍；而这一次既然是复习 &amp;amp; 查错，同时利用 orgmode 嵌入代码块及 scheme
的解释性语言的特点，可以在组织文章的同时运行～修改代码，这是效仿使用
orgmode 文档嵌入 elisp 代码块构成 emacs 配置文件的做法，许多 emacs大佬用这
种手法提高配置文件可读性。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;
有些书就是值得一遍又一遍的反复咀嚼，毫无疑问 &lt;i&gt;SICP&lt;/i&gt; 就是其中的一员。
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgdc1db89" class="outline-2"&gt;
&lt;h2 id="orgdc1db89"&gt;第一章&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-orgdc1db89"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org1cda8a3" class="outline-3"&gt;
&lt;h3 id="org1cda8a3"&gt;程序设计的基本元素&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org1cda8a3"&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgdfa1505" class="outline-4"&gt;
&lt;h4 id="orgdfa1505"&gt;表达式&lt;/h4&gt;
&lt;/div&gt;

&lt;div id="outline-container-org8d2c85b" class="outline-4"&gt;
&lt;h4 id="org8d2c85b"&gt;命名和环境&lt;/h4&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgabfa60c" class="outline-4"&gt;
&lt;h4 id="orgabfa60c"&gt;组合式的求值&lt;/h4&gt;
&lt;/div&gt;

&lt;div id="outline-container-org8fe2365" class="outline-4"&gt;
&lt;h4 id="org8fe2365"&gt;复合过程&lt;/h4&gt;
&lt;/div&gt;

&lt;div id="outline-container-org4996385" class="outline-4"&gt;
&lt;h4 id="org4996385"&gt;过程应用的代换模形&lt;/h4&gt;
&lt;/div&gt;

&lt;div id="outline-container-org654334d" class="outline-4"&gt;
&lt;h4 id="org654334d"&gt;条件表达式何谓词&lt;/h4&gt;
&lt;/div&gt;

&lt;div id="outline-container-org4de3018" class="outline-4"&gt;
&lt;h4 id="org4de3018"&gt;实例：采用牛顿法求平方根&lt;/h4&gt;
&lt;/div&gt;

&lt;div id="outline-container-org2d5ab8d" class="outline-4"&gt;
&lt;h4 id="org2d5ab8d"&gt;过程作为黑箱抽象&lt;/h4&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org5e7a1d1" class="outline-3"&gt;
&lt;h3 id="org5e7a1d1"&gt;过程与它们所产生的计算&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org5e7a1d1"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org4acd399" class="outline-4"&gt;
&lt;h4 id="org4acd399"&gt;线性的递归和迭代&lt;/h4&gt;
&lt;/div&gt;

&lt;div id="outline-container-org2c73240" class="outline-4"&gt;
&lt;h4 id="org2c73240"&gt;树形递归&lt;/h4&gt;
&lt;/div&gt;

&lt;div id="outline-container-orga457fca" class="outline-4"&gt;
&lt;h4 id="orga457fca"&gt;增长的阶&lt;/h4&gt;
&lt;/div&gt;

&lt;div id="outline-container-org5229aa7" class="outline-4"&gt;
&lt;h4 id="org5229aa7"&gt;求幂&lt;/h4&gt;
&lt;/div&gt;

&lt;div id="outline-container-org5a8757e" class="outline-4"&gt;
&lt;h4 id="org5a8757e"&gt;最大公约数&lt;/h4&gt;
&lt;/div&gt;

&lt;div id="outline-container-org1026282" class="outline-4"&gt;
&lt;h4 id="org1026282"&gt;实例：素数检测&lt;/h4&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgf302726" class="outline-3"&gt;
&lt;h3 id="orgf302726"&gt;用高阶函数做抽象&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-orgf302726"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org4685021" class="outline-4"&gt;
&lt;h4 id="org4685021"&gt;过程作为参数&lt;/h4&gt;
&lt;/div&gt;

&lt;div id="outline-container-orge85d4c1" class="outline-4"&gt;
&lt;h4 id="orge85d4c1"&gt;用 lambda 构造过程&lt;/h4&gt;
&lt;/div&gt;

&lt;div id="outline-container-org444b6cb" class="outline-4"&gt;
&lt;h4 id="org444b6cb"&gt;过程作为一般性的方法&lt;/h4&gt;
&lt;/div&gt;

&lt;div id="outline-container-orgdb542ae" class="outline-4"&gt;
&lt;h4 id="orgdb542ae"&gt;过程作为返回值&lt;/h4&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><category>Scheme</category><category>SICP</category><guid>https://zero4drift.github.io/posts/sicp-refresher-chapter-1/</guid><pubDate>Thu, 13 Dec 2018 12:41:57 GMT</pubDate></item></channel></rss>