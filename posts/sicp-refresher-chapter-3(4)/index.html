<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " vocab="http://ogp.me/ns" lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="Refresher of SICP chapter 3.4 Modularity, Objects, and State 模块化，对象和状态">
<meta name="viewport" content="width=device-width">
<title>SICP-Refresher-Chapter-3(4) | 钉钉是世界上最傻逼的app</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<link rel="alternate" type="application/rss+xml" title="RSS" href="../../rss.xml">
<link rel="canonical" href="https://zero4drift.github.io/posts/sicp-refresher-chapter-3%284%29/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="zero4drift">
<meta property="og:site_name" content="钉钉是世界上最傻逼的app">
<meta property="og:title" content="SICP-Refresher-Chapter-3(4)">
<meta property="og:url" content="https://zero4drift.github.io/posts/sicp-refresher-chapter-3%284%29/">
<meta property="og:description" content="Refresher of SICP chapter 3.4 Modularity, Objects, and State 模块化，对象和状态">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2019-01-03T11:55:34+08:00">
<meta property="article:tag" content="Scheme">
<meta property="article:tag" content="SICP">
</head>
<body>
    

    <header id="header" class="navbar"><div class="container">
            
    <div class="brand">

        <div class="brand-text">
            <a href="https://zero4drift.github.io/" title="钉钉是世界上最傻逼的app" rel="home">
                钉钉是世界上最傻逼的app
            </a>
        </div>

        <a id="btn-toggle-nav" class="navbar-toggle">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </a>
    </div>

            
    <nav class="navbar-collapse collapse"><ul class="nav">
<li><a href="../../archive.html">Archive</a></li>
                <li><a href="https://github.com/zero4drift">Github</a></li>
                <li><a href="../../categories/">Tags</a></li>
                <li><a href="../../rss.xml">RSS feed</a></li>
    
    
    </ul></nav>
</div>
    </header><div class="header-padding"> </div>

    
    <div class="post-header">
        <div class="container">
            <div class="title">
                SICP-Refresher-Chapter-3(4)
            </div>
        </div>
    </div>

    <div class="post-meta">
      <div class="container">
	<div class="meta clearfix">
	  <div class="authordate">
	    <time class="timeago" datetime="2019-01-03T11:55:34+08:00">2019/01/03</time>
</div>
	  <div class="post-tags">
	    <div class="tag">
	      <a href="../../categories/scheme/" rel="tag">Scheme</a>
	    </div>
	    <div class="tag">
	      <a href="../../categories/sicp/" rel="tag">SICP</a>
	    </div>
	  </div>
	</div>
      </div>
    </div>
    
    
    <div id="post-main" class="main">
        <div class="container">
        <div id="outline-container-orgc7980e8" class="outline-2">
<h2 id="orgc7980e8">并发：时间是一个本质问题</h2>
<div class="outline-text-2" id="text-orgc7980e8">
<ol class="org-ol">
<li>潜藏在状态、同一、变化后面的中心问题是，引入赋值之后，我们就必须承认时间在
所有的计算模形中的位置；</li>
<li>采用具有局部状态的计算对象建立模形，就会迫使我们去直面时间问题，并将它作为
程序设计中一个一个必不可少的概念；</li>
<li>将计算模形划分为一些能各自独立地并发演化的部分，常常也是很合适的，即使有关
的程序是在一台计算机上顺序执行，在实际写程序时就像它们将被并发地执行那样，
也能帮助程序员们避免那些并不必要的时间约束，因此也可能使程序更加模块化；</li>
<li>除了使程序更加模块化之外，并发计算还可能提供某种超越顺序计算的速度优势；</li>
<li>在出现了并发的情况下，由赋值引入的复杂性问题将变得更加严重，会在我们对时间
的理解中加入进一步的复杂性；</li>
</ol>
</div>

<div id="outline-container-org172db63" class="outline-3">
<h3 id="org172db63">并发系统中时间的性质</h3>
<div class="outline-text-3" id="text-org172db63">
<ol class="org-ol">
<li>对于并发的一种可能限制方式是规定，修改任意共享状态变量的两个操作都不允许
同时发生；</li>
<li>对于并发的另一种不那么严厉的限制方式是，保证并发系统产生出的结果与各个进
程按照 <b>某种</b> 方式顺序运行产生出的结果完全一样；</li>
</ol>
</div>
</div>

<div id="outline-container-orgd7b4021" class="outline-3">
<h3 id="orgd7b4021">练习 3.38</h3>
<div class="outline-text-3" id="text-orgd7b4021">
<div class="highlight"><pre><span></span>    <span class="c1">;; 完全是体力活，列出各种排列组合...</span>
    <span class="c1">;; 就在这里列举了。</span>
</pre></div>
</div>
</div>

<div id="outline-container-org2571f9d" class="outline-3">
<h3 id="org2571f9d">控制并发的机制</h3>
<div class="outline-text-3" id="text-org2571f9d">
<ol class="org-ol">
<li>在设计并发系统时，设法做出一些一般性的机制，使我们可能限制并行进程之间的
交错情况，以保证程序具有正确的行为方式；</li>
<li>串行化就是实现下面的想法：使进程可以并发地执行，但是其中也有一些过程不能
并发地执行，说的更准确些，串行化就是创建一些不同的过程集合，并且保证在每
个时刻，在任何一个串行化集合里至多只有一个过程的一个执行；</li>
<li>借助串行化去控制对共享变量的访问，举例说，如果我们希望基于某个共享变量已
有的值去更新它，那么就应该将访问这一变量的现有值和给这一变量赋新值的操作
都放入同一个过程里，而后设法保证，任何能给这个变量赋值的过程都不会与这个
过程并发运行，方法就是将所有这样的过程都放在同一个串行化集合里；</li>
<li>如果只存在一个共享资源，串行化的使用问题是相对比较简单的；如果存在着多项
共享资源并发程序设计就可能变得非常难以把握了；</li>
<li>使用一种更基本的称为 <b>互斥元</b> 的同步机制来实现串行化，互斥元是一种对象，
假定它提供了两个操作：获取(acquired) 和释放(release)；</li>
<li>在那些提供了对于多种共享资源的开发访问的系统里，总是存在着死锁的危险；</li>
</ol>
</div>
</div>

<div id="outline-container-org706ac8a" class="outline-3">
<h3 id="org706ac8a">练习 3.39-3.49</h3>
<div class="outline-text-3" id="text-org706ac8a">
</div>
<div id="outline-container-org7fb5843" class="outline-4">
<h4 id="org7fb5843">3.39</h4>
<div class="outline-text-4" id="text-org7fb5843">
<div class="highlight"><pre><span></span>     <span class="c1">;; 121</span>
     <span class="c1">;; 101</span>
     <span class="c1">;; 100</span>
</pre></div>
</div>
</div>

<div id="outline-container-org97637fa" class="outline-4">
<h4 id="org97637fa">3.40</h4>
<div class="outline-text-4" id="text-org97637fa">
<div class="highlight"><pre><span></span>     <span class="c1">;; without serialization</span>
     <span class="c1">;; 1000000</span>
     <span class="c1">;; 100</span>
     <span class="c1">;; 1000</span>
     <span class="c1">;; 10000</span>
     <span class="c1">;; 100000</span>

     <span class="c1">;; with serialization</span>
     <span class="c1">;; 1000000</span>
</pre></div>
</div>
</div>

<div id="outline-container-org3207a60" class="outline-4">
<h4 id="org3207a60">3.41</h4>
<div class="outline-text-4" id="text-org3207a60">
<div class="highlight"><pre><span></span>     <span class="c1">;; 并没有必要；</span>
     <span class="c1">;; 第一，非串行地访问帐户过程并不会影响其他两个过程的结果；</span>
     <span class="c1">;; 第二，可能存在一种担心，即非串行地访问帐户取到的值是不正确的，</span>
     <span class="c1">;; 因为访问帐户可能处于其他并发过程的取值和修改值之间，</span>
     <span class="c1">;; 访问帐户取到的值马上就无效了；</span>
     <span class="c1">;; 这是不用担心的，因为可以这样说，访问帐户取值取的就是那一时刻的值。</span>
</pre></div>
</div>
</div>

<div id="outline-container-org5054f17" class="outline-4">
<h4 id="org5054f17">3.42</h4>
<div class="outline-text-4" id="text-org5054f17">
<div class="highlight"><pre><span></span>     <span class="c1">;; 安全的；</span>
     <span class="c1">;; 与原来的版本并无什么不同；</span>
</pre></div>
</div>
</div>

<div id="outline-container-orgf8855da" class="outline-4">
<h4 id="orgf8855da">3.43</h4>
<div class="outline-text-4" id="text-orgf8855da">
<div class="highlight"><pre><span></span>     <span class="c1">;; 顺序运行交换过程</span>
     <span class="c1">;; 10 20 30</span>
     <span class="c1">;; 10 30 20</span>
     <span class="c1">;; 20 10 30</span>
     <span class="c1">;; 20 30 10</span>
     <span class="c1">;; 30 10 20</span>
     <span class="c1">;; 30 20 10</span>

     <span class="c1">;; 使用本节第一个版本的帐户交换程序</span>
     <span class="c1">;; 10 20 30</span>
     <span class="c1">;; 40 10 10</span>
     <span class="c1">;; 20 20 20</span>
     <span class="c1">;; 30 30 0</span>
     <span class="c1">;; 10 40 10</span>
     <span class="c1">;; 0 30 30</span>
     <span class="c1">;; 30 0 30</span>
     <span class="c1">;; 10 10 40</span>
     <span class="c1">;; 20 10 30</span>
     <span class="c1">;; 30 20 10</span>
     <span class="c1">;; 10 30 20</span>
     <span class="c1">;; 30 10 20</span>
     <span class="c1">;; 20 30 10</span>
</pre></div>
</div>
</div>

<div id="outline-container-orgc755909" class="outline-4">
<h4 id="orgc755909">3.44</h4>
<div class="outline-text-4" id="text-orgc755909">
<div class="highlight"><pre><span></span>     <span class="c1">;; Louis 的说法是错的；</span>

     <span class="c1">;; 帐户余额交换过程中必须先计算帐户差额，</span>
     <span class="c1">;; 而这个差额计算过程是可以与其他对这两个帐户的操作并行进行的，</span>
     <span class="c1">;; 导致计算出来的差额可能是错误的，所以需要串行化整个 exchange 过程；</span>

     <span class="c1">;; 而转移款项 transfer 过程中对帐户的所有操作都受到串行化组的保护；</span>
     <span class="c1">;; 不必担心最初的 exchange 中出现的问题。</span>
</pre></div>
</div>
</div>

<div id="outline-container-org61e33a2" class="outline-4">
<h4 id="org61e33a2">3.45</h4>
<div class="outline-text-4" id="text-org61e33a2">
<div class="highlight"><pre><span></span>     <span class="c1">;; 当调用本节定义的 serialized-exchange 时，会出现死锁，</span>

     <span class="c1">;; 串行化组里的并发过程运行 将卡在某个节点无法运行下去；</span>
     <span class="c1">;; 比如，现在 exchange 过程在 serializer2 串行化组里；</span>
     <span class="c1">;; 而 (serializer2 exchange) 过程在 serializer1 组里；</span>
     <span class="c1">;; 当运行此 exchange 过程时，</span>
     <span class="c1">;; (account 'withdraw) 与 (account 'deposit) 将返回两个被串行化的过程，</span>
     <span class="c1">;; 分别属于串行化组 serializer1 和 serializer2，</span>
     <span class="c1">;; exchange 过程内部的两个串行化过程必须等待同组的进程结束；</span>
     <span class="c1">;; 而此时这两个组里都有过程作为进程在运行，</span>
     <span class="c1">;; 即前面所说的 (serializer2 exchange) 和 exchange 本身;</span>
     <span class="c1">;; 如此 exchange 将永远无法结束，这个调用将会死锁。</span>
</pre></div>
</div>
</div>

<div id="outline-container-orgae90690" class="outline-4">
<h4 id="orgae90690">3.46</h4>
<div class="outline-text-4" id="text-orgae90690">
<div class="highlight"><pre><span></span>     <span class="c1">;; 如果没有企图使 test-and-set! 的操作原子化，</span>
     <span class="c1">;; 两个并发进程就可以同时获取互斥元并进而运行下去，</span>
     <span class="c1">;; 这是与以互斥元实现串行化的初衷相背的。</span>
     <span class="c1">;; 画时序图是重复劳动，这里就不做了。</span>
</pre></div>
</div>
</div>

<div id="outline-container-org78db7ca" class="outline-4">
<h4 id="org78db7ca">3.47</h4>
<div class="outline-text-4" id="text-org78db7ca">
<div class="highlight"><pre><span></span>     <span class="c1">;; a</span>

     <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-semaphore</span> <span class="nv">n</span><span class="p">)</span>
       <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">mutex</span> <span class="p">(</span><span class="nf">make-mutex</span><span class="p">))</span>
	     <span class="p">(</span><span class="nf">original-n</span> <span class="nv">n</span><span class="p">))</span>
	 <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">acquire</span><span class="p">)</span>
	   <span class="p">(</span><span class="nf">mutex</span> <span class="ss">'acquire</span><span class="p">)</span>
	   <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">n</span> <span class="mi">0</span><span class="p">)</span>
	       <span class="p">(</span><span class="k">begin </span><span class="p">(</span><span class="k">set! </span><span class="nv">n</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">))</span>
		      <span class="p">(</span><span class="nf">mutex</span> <span class="ss">'release</span><span class="p">)</span>
		      <span class="ss">'ok</span><span class="p">)</span>
	       <span class="p">(</span><span class="k">begin </span><span class="p">(</span><span class="nf">mutex</span> <span class="ss">'release</span><span class="p">)</span>
		      <span class="p">(</span><span class="nf">acquire</span><span class="p">))))</span>
	 <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">release</span><span class="p">)</span>
	   <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">n</span> <span class="nv">original-n</span><span class="p">)</span>
	       <span class="p">(</span><span class="k">begin </span><span class="p">(</span><span class="nf">mutex</span> <span class="ss">'acquire</span><span class="p">)</span>
		      <span class="p">(</span><span class="k">set! </span><span class="nv">n</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">n</span> <span class="mi">1</span><span class="p">))</span>
		      <span class="p">(</span><span class="nf">mutex</span> <span class="ss">'release</span><span class="p">)</span>
		      <span class="ss">'ok</span><span class="p">)))</span>
	 <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">the-semaphore</span> <span class="nv">m</span><span class="p">)</span>
	   <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">eq? </span><span class="nv">m</span> <span class="ss">'acquire</span><span class="p">)</span>
		  <span class="p">(</span><span class="nf">acquire</span><span class="p">))</span>
		 <span class="p">((</span><span class="nb">eq? </span><span class="nv">m</span> <span class="ss">'release</span><span class="p">)</span>
		  <span class="p">(</span><span class="nf">release</span><span class="p">))))</span>
	 <span class="nv">the-semaphore</span><span class="p">))</span>

     <span class="c1">;; b</span>

     <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-semaphore</span> <span class="nv">n</span><span class="p">)</span>
       <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">original-n</span> <span class="nv">n</span><span class="p">))</span>
	 <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">acquire</span><span class="p">)</span>
	   <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">test-and-set!</span> <span class="nv">n</span><span class="p">)</span>
	       <span class="p">(</span><span class="nf">acquire</span><span class="p">)</span>
	       <span class="ss">'ok</span><span class="p">))</span>
	 <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">release</span><span class="p">)</span>
	   <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&lt; </span><span class="nv">n</span> <span class="nv">original-n</span><span class="p">)</span>
	       <span class="p">(</span><span class="nf">begin</span>
		 <span class="p">(</span><span class="k">set! </span><span class="nv">n</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">n</span> <span class="mi">1</span><span class="p">))</span>
		 <span class="ss">'ok</span><span class="p">)))</span>
	 <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">the-semaphore</span> <span class="nv">m</span><span class="p">)</span>
	   <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">eq? </span><span class="nv">m</span> <span class="ss">'acquire</span><span class="p">)</span>
		  <span class="p">(</span><span class="nf">acquire</span><span class="p">))</span>
		 <span class="p">((</span><span class="nb">eq? </span><span class="nv">m</span> <span class="ss">'release</span><span class="p">)</span>
		  <span class="p">(</span><span class="nf">release</span><span class="p">))))</span>
	 <span class="nv">the-semaphore</span><span class="p">))</span>

     <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">test-and-set!</span> <span class="nv">n</span><span class="p">)</span>
       <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">n</span> <span class="mi">0</span><span class="p">)</span>
	   <span class="nv">true</span>
	   <span class="p">(</span><span class="k">begin </span><span class="p">(</span><span class="k">set! </span><span class="nv">n</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">))</span>
		  <span class="nv">false</span><span class="p">)))</span>
</pre></div>
</div>
</div>

<div id="outline-container-org04a5da2" class="outline-4">
<h4 id="org04a5da2">3.48</h4>
<div class="outline-text-4" id="text-org04a5da2">
<div class="highlight"><pre><span></span>     <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">make-account-and-serializer</span> <span class="nv">balance</span> <span class="nv">n</span><span class="p">)</span>
       <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">withdraw</span> <span class="nv">amount</span><span class="p">)</span>
	 <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt;= </span><span class="nv">balance</span> <span class="nv">amount</span><span class="p">)</span>
	     <span class="p">(</span><span class="k">begin </span><span class="p">(</span><span class="k">set! </span><span class="nv">balance</span> <span class="p">(</span><span class="nb">- </span><span class="nv">balance</span> <span class="nv">amount</span><span class="p">))</span>
		    <span class="nv">balance</span><span class="p">)</span>
	     <span class="s">"Insufficient funds"</span><span class="p">))</span>
       <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">deposit</span> <span class="nv">amount</span><span class="p">)</span>
	 <span class="p">(</span><span class="k">set! </span><span class="nv">balance</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">balance</span> <span class="nv">amount</span><span class="p">))</span>
	 <span class="nv">balance</span><span class="p">)</span>
       <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">balance-serializer</span> <span class="p">(</span><span class="nf">make-serializer</span><span class="p">)))</span>
	 <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">dispatch</span> <span class="nv">m</span><span class="p">)</span>
	   <span class="p">(</span><span class="k">cond </span><span class="p">((</span><span class="nb">eq? </span><span class="nv">m</span> <span class="ss">'withdraw</span><span class="p">)</span> <span class="nv">withdraw</span><span class="p">)</span>
		 <span class="p">((</span><span class="nb">eq? </span><span class="nv">m</span> <span class="ss">'deposit</span><span class="p">)</span> <span class="nv">deposit</span><span class="p">)</span>
		 <span class="p">((</span><span class="nb">eq? </span><span class="nv">m</span> <span class="ss">'balance</span><span class="p">)</span> <span class="nv">balance</span><span class="p">)</span>
		 <span class="p">((</span><span class="nb">eq? </span><span class="nv">m</span> <span class="ss">'serializer</span><span class="p">)</span> <span class="nv">balance-serializer</span><span class="p">)</span>
		 <span class="p">((</span><span class="nb">eq? </span><span class="nv">m</span> <span class="ss">'label</span><span class="p">)</span> <span class="nv">n</span><span class="p">)</span>
		 <span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nf">error</span> <span class="s">"Unknown request -- MAKE-ACCOUNT"</span>
			      <span class="nv">m</span><span class="p">))))</span>
	 <span class="nv">dispatch</span><span class="p">))</span>

     <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">label</span> <span class="nv">acc</span><span class="p">)</span>
       <span class="p">(</span><span class="nf">acc</span> <span class="ss">'label</span><span class="p">))</span>

     <span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">serialized-exchange</span> <span class="nv">account1</span> <span class="nv">account2</span><span class="p">)</span>
       <span class="p">(</span><span class="k">let </span><span class="p">((</span><span class="nf">serializer1</span> <span class="p">(</span><span class="nf">account1</span> <span class="ss">'serializer</span><span class="p">))</span>
	     <span class="p">(</span><span class="nf">serializer2</span> <span class="p">(</span><span class="nf">account2</span> <span class="ss">'serializer</span><span class="p">))</span>
	     <span class="p">(</span><span class="nf">n1</span> <span class="p">(</span><span class="nf">label</span> <span class="nv">account1</span><span class="p">))</span>
	     <span class="p">(</span><span class="nf">n2</span> <span class="p">(</span><span class="nf">label</span> <span class="nv">account2</span><span class="p">)))</span>
	 <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">n1</span> <span class="nv">n2</span><span class="p">)</span>
	     <span class="p">((</span><span class="nf">serializer2</span> <span class="p">(</span><span class="nf">serializer1</span> <span class="nv">exchage</span><span class="p">))</span>
	      <span class="nv">account1</span>
	      <span class="nv">account2</span><span class="p">)</span>
	     <span class="p">((</span><span class="nf">serializer1</span> <span class="p">(</span><span class="nf">serializer2</span> <span class="nv">exchage</span><span class="p">)))</span>
	     <span class="nv">account1</span>
	     <span class="nv">account2</span><span class="p">)))</span>
</pre></div>
</div>
</div>

<div id="outline-container-orgd4a0ea6" class="outline-4">
<h4 id="orgd4a0ea6">3.49</h4>
<div class="outline-text-4" id="text-orgd4a0ea6">
<div class="highlight"><pre><span></span>     <span class="c1">;; 竟然无法理解自己之前写的回答了...</span>
     <span class="c1">;; 摘录一条别人的情形描述：</span>
     <span class="c1">;; https://sicp.readthedocs.io/en/latest/chp3/49.html</span>

     <span class="c1">;; 关联帐号的其中一种状况产生的死锁无法使用 练习 3.48 的机制来防止。</span>

     <span class="c1">;; 假设 peter 和 mary 是两夫妇，他们各自拥有自己的帐号 peter-acc 和 mary-acc ，并且这两个帐号都将对方的帐号设置成了关联帐号，也即是，当 peter-acc 的余额不足以支付的时候，它会去提取 mary-acc 的余额；而当 mary-acc 的余额不足以支付的时候，它也回去提取 peter-acc 的余额。</span>

     <span class="c1">;; 现在，考虑这样一种情况， peter 和 mary 分别在不同的地方消费，然后各自账户的余额都不足以支付订单，于是 peter-acc 尝试访问关联帐号 mary-acc ，而 mary-acc 也在同一时间访问 peter-acc ，因为两个帐号都已经被打开，而且两个帐号都试图访问关联帐号，这样就造成了一个死锁：除非 peter 或 mary 的其中一个主动退出账户，否则支付永远都无法完成。</span>
</pre></div>
</div>
</div>
</div>
</div>
            
        
        <div id="disqus_thread"></div>
        <script>
        var disqus_shortname ="https-zero4drift-github-io",
            disqus_url="https://zero4drift.github.io/posts/sicp-refresher-chapter-3%284%29/",
        disqus_title="SICP-Refresher-Chapter-3(4)",
        disqus_identifier="cache/posts/sicp-refresher-chapter-3(4).html",
        disqus_config = function () {
            this.language = "en";
        };
        (function() {
            var dsq = document.createElement('script'); dsq.async = true;
            dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
</noscript>
    <a href="https://disqus.com" class="dsq-brlink" rel="nofollow">Comments powered by <span class="logo-disqus">Disqus</span></a>


        
    


        </div>
    </div>

    
    <footer><div class="container">
            <div class="social">



                <div class="social-entry">
                    <a href="../../rss.xml" target="_blank">
                        <i class="fa fa-rss"></i> 
                    </a>
                </div>
            </div>
                <div class="copyright">
                    Contents © 2019         <a href="mailto:fang0052@e.ntu.edu.sg">zero4drift</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         
                    
                </div>
           
        </div>
    </footer><script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?06e0ade16d98033ac1aad78106d873c8";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script src="../../assets/js/all-nocdn.js" type="text/javascript"></script>
</body>
</html>
