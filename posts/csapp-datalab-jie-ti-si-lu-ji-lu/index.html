<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="CSAPP-lab assignements datalab 的解题思路，关于 bitAnd, getByte,">
<meta name="viewport" content="width=device-width">
<title>CSAPP-datalab 解题思路记录 | Procrastination Prescription</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<link rel="alternate" type="application/rss+xml" title="RSS" href="../../rss.xml">
<link rel="canonical" href="https://zero4drift.github.io/posts/csapp-datalab-jie-ti-si-lu-ji-lu/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]-->
</head>
<body>
<div class="container" id="container">
    <!--Body content-->
    <!--End of body content-->
    <div>
    <a href="https://zero4drift.github.io/"><h1>Procrastination Prescription</h1></a>
    </div>
    <div id="content">
        
        
    <div class="postdiv">
    <a href="."><h2>CSAPP-datalab 解题思路记录</h2></a>
    <div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">datalab 解题思路</h2>
<div class="outline-text-2" id="text-1">
<p>
本篇文章并不会花太长时间，因为解题思路都写在代码注释中了（写代码的时候用注释描述
整体方向和关键步骤实在是个好习惯）。
</p>

<p>
代码中的注释都是用蹩脚的英文写就的，虽然说不能保证没有语法问题，但是一般不会太影响理
解。
</p>

<p>
一共15道题目，12道关于 int 类型数据操作，3道关于 single float 类型操作，难的容易的都
有，分布还算合理。基本上代码中的注释就够解释清楚了，不过对于 <a href="#sec-1-4">bitCount</a> 这道题
（说好的只是二进制操作谜题，怎么二分法都乱入了？）会详细解释。
</p>

<ol class="org-ol">
<li>
<a href="#sec-1-1">bitAnd</a>
</li>
<li>
<a href="#sec-1-2">getByte</a>
</li>
<li>
<a href="#sec-1-3">logicalShift</a>
</li>
<li>
<a href="#sec-1-4">bitCount</a>
</li>
<li>
<a href="#sec-1-5">bang</a>
</li>
<li>
<a href="#sec-1-6">tmin</a>
</li>
<li>
<a href="#sec-1-7">fitsBits</a>
</li>
<li>
<a href="#sec-1-8">divpwr2</a>
</li>
<li>
<a href="#sec-1-9">negate</a>
</li>
<li>
<a href="#sec-1-10">isPositive</a>
</li>
<li>
<a href="#sec-1-11">isLessOrEqual</a>
</li>
<li>
<a href="#sec-1-12">ilog2</a>
</li>
<li>
<a href="#sec-1-13">float<sub>neg</sub></a>
</li>
<li>
<a href="#sec-1-14">float<sub>i2f</sub></a>
</li>
<li>
<a href="#sec-1-15">float<sub>twice</sub></a>
</li>
</ol>
<!-- TEASER_END -->
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">bitAnd</h3>
<div class="outline-text-3" id="text-1-1">
/* 
 * bitAnd - x&amp;y using only ~ and | 
 *   Example: bitAnd(6, 5) = 4
 *   Legal ops: ~ |
 *   Max ops: 8
 *   Rating: 1
 */
int bitAnd(int x, int y) {
  /* ~(~ x | ~y) = x &amp; y */
  return ~ (~ x | ~ y);
}
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">getByte</h3>
<div class="outline-text-3" id="text-1-2">
/* 
 * getByte - Extract byte n from word x
 *   Bytes numbered from 0 (LSB) to 3 (MSB)
 *   Examples: getByte(0x12345678,1) = 0x56
 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 6
 *   Rating: 2
 */
int getByte(int x, int n) {
  /* Left shift, right shift and mask */
  int shift = n &lt;&lt; 3;
  int result = x &gt;&gt; shift;
  return 0xFF &amp; result;
}
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">logicalShift</h3>
<div class="outline-text-3" id="text-1-3">
/* 
 * logicalShift - shift x to the right by n, using a logical shift
 *   Can assume that 0 &lt;= n &lt;= 31
 *   Examples: logicalShift(0x87654321,4) = 0x08765432
 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 20
 *   Rating: 3 
 */
int logicalShift(int x, int n) {
  /* Make a mask */
  int z = 1 &lt;&lt; 31;
  int filter = ~ ((z &gt;&gt; n) &lt;&lt; 1);
  int result = (x &gt;&gt; n) &amp; filter;
  return result;
}
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">bitCount</h3>
<div class="outline-text-3" id="text-1-4">
/*
 * bitCount - returns count of number of 1's in word
 *   Examples: bitCount(5) = 2, bitCount(7) = 3
 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 40
 *   Rating: 4
 */
int bitCount(int x) {
  /* This one is beyond, I cheat */
  int temp_mask1 = 0x55 | (0x55 &lt;&lt; 8);
  int temp_mask2 = 0x33 | (0x33 &lt;&lt; 8);
  int temp_mask3 = 0x0f | (0x0f &lt;&lt; 8);
  int mask1 = temp_mask1 | (temp_mask1 &lt;&lt; 16);
  int mask2 = temp_mask2 | (temp_mask2 &lt;&lt; 16);
  int mask3 = temp_mask3 | (temp_mask3 &lt;&lt; 16);
  int mask4 = 0xff | (0xff &lt;&lt; 16);
  int mask5 = 0xff | (0xff &lt;&lt; 8);
  x = (x &amp; mask1) + ((x &gt;&gt; 1) &amp; mask1);
  x = (x &amp; mask2) + ((x &gt;&gt; 2) &amp; mask2);
  x = (x &amp; mask3) + ((x &gt;&gt; 4) &amp; mask3);
  x = (x &amp; mask4) + ((x &gt;&gt; 8) &amp; mask4);
  x = (x &amp; mask5) + ((x &gt;&gt; 16) &amp; mask5);
  return x;
}
</div>

<div id="outline-container-sec-1-4-1" class="outline-4">
<h4 id="sec-1-4-1">步骤推演</h4>
<div class="outline-text-4" id="text-1-4-1">
<p>
其实就是二分法（或者二分法的变种？本文中 <a href="#sec-1-12">ilog2</a> 函数的解法也是二分法，它的解决
方法就不详细推演了）。
</p>

<p>
假设传入参数是 0xffffffff，也就是说，二进制表示全是1。
</p>

<ol class="org-ol">
<li>过筛，统计传入参数的二进制表示上，每两个位置有几个1，可能的个数：0，1，2，下面使用表格来展示筛选过程
</li>
</ol>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup>
<col class="left">
<col class="right">
<col class="right">
<col class="right">
<col class="right">
<col class="right">
<col class="right">
<col class="right">
<col class="right">
<col class="right">
<col class="right">
<col class="right">
<col class="right">
<col class="right">
<col class="right">
<col class="right">
<col class="right">
<col class="right">
<col class="right">
<col class="right">
<col class="right">
<col class="right">
<col class="right">
<col class="right">
<col class="right">
<col class="right">
<col class="right">
<col class="right">
<col class="right">
<col class="right">
<col class="right">
<col class="right">
<col class="right">
</colgroup>
<tbody>
<tr>
<td class="left">index</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">2</td>
<td class="right">3</td>
<td class="right">4</td>
<td class="right">5</td>
<td class="right">6</td>
<td class="right">7</td>
<td class="right">8</td>
<td class="right">9</td>
<td class="right">10</td>
<td class="right">11</td>
<td class="right">12</td>
<td class="right">13</td>
<td class="right">14</td>
<td class="right">15</td>
<td class="right">16</td>
<td class="right">17</td>
<td class="right">18</td>
<td class="right">19</td>
<td class="right">20</td>
<td class="right">21</td>
<td class="right">22</td>
<td class="right">23</td>
<td class="right">24</td>
<td class="right">25</td>
<td class="right">26</td>
<td class="right">27</td>
<td class="right">28</td>
<td class="right">29</td>
<td class="right">30</td>
<td class="right">31</td>
</tr>
<tr>
<td class="left">bits</td>
<td class="right">1</td>
<td class="right">1</td>
<td class="right">1</td>
<td class="right">1</td>
<td class="right">1</td>
<td class="right">1</td>
<td class="right">1</td>
<td class="right">1</td>
<td class="right">1</td>
<td class="right">1</td>
<td class="right">1</td>
<td class="right">1</td>
<td class="right">1</td>
<td class="right">1</td>
<td class="right">1</td>
<td class="right">1</td>
<td class="right">1</td>
<td class="right">1</td>
<td class="right">1</td>
<td class="right">1</td>
<td class="right">1</td>
<td class="right">1</td>
<td class="right">1</td>
<td class="right">1</td>
<td class="right">1</td>
<td class="right">1</td>
<td class="right">1</td>
<td class="right">1</td>
<td class="right">1</td>
<td class="right">1</td>
<td class="right">1</td>
<td class="right">1</td>
</tr>
<tr>
<td class="left">mask1</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
</tr>
<tr>
<td class="left">mask-x</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
</tr>
<tr>
<td class="left">mask-x-right-shift-by-one</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
</tr>
<tr>
<td class="left">masked1+masked2</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">0</td>
</tr>
</tbody>
</table>
<p>
使用表格中所所示的 mask 对 x 进行筛选，找出每两位低位上是否有1，有的话低位上用1表示，表示此位有1个1；
</p>

<p>
再用 mask 对右移一位的 x 进行筛选，找出原 x 上每两位高位上是否有1，有的话结果中每两位的低位上用1表示，表示此位有1个1；
</p>

<p>
将筛选后的两个结果相加，得到的结果的二进制表示如果每两位高位上是1的话，表示原 x 中该两位范围内有2个1；如果是1，则表示有1个1；如果是0，则0。
</p>

<ol class="org-ol">
<li>换一个二进制表示位 0x33333333 的 mask 继续过筛，即进行上次获得的结果中每四位有多少个1的计算。
</li>
</ol>
<p>
3 …
</p>

<ol class="org-ol">
<li>以此类推，不再赘述，最后获得的结果就是 x 的二进制表示中有多少个1。
</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5">bang</h3>
<div class="outline-text-3" id="text-1-5">
/* 
 * bang - Compute !x without using !
 *   Examples: bang(3) = 0, bang(0) = 1
 *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 12
 *   Rating: 4 
 */
int bang(int x) {
  /* When x is 0, temp1 is overflow, it's value is 0 */
  int temp1 = ~ x + 1;
  /* When x is 0, temp2 is 0, else its top most bit must be 1 */
  int temp2 = x | temp1;
  /* Negation' mainly purpose is to swtich the top most bit */
  /* x = 0, temp3 = 0xffffffff; else temp3 = 0x0... */
  int temp3 = ~ temp2;
  /* Right shift of 31 bits */
  /* x = 0, mask = 0xffffffff; else mask = 0 */
  int mask = temp3 &gt;&gt; 31;
  return mask &amp; 1;
}
</div>
</div>

<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6">tmin</h3>
<div class="outline-text-3" id="text-1-6">
/* 
 * tmin - return minimum two's complement integer 
 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 4
 *   Rating: 1
 */
int tmin(void) {
  /* A n-bit integer could make 0xffffffff binary representations
   * According to the law of two's complement
   * Top most bit of int type is used to define a positive or a negative
   * There are 0xffffffff / 2 numbers of positive int representations
   * Then the maximum positive int number is 0xffffffff / 2
   * We know the total number, so we could compute the minimum negative integer
   * in two's complement style
   */
  int max_n_bit_range = ~ 0x0;
  int mask = 0x1 &lt;&lt; 31;
  int max_post_int = max_n_bit_range ^ mask;
  int min_nega_int = ~ max_post_int;
  return min_nega_int;
}
</div>
</div>

<div id="outline-container-sec-1-7" class="outline-3">
<h3 id="sec-1-7">fitsBits</h3>
<div class="outline-text-3" id="text-1-7">
/* 
 * fitsBits - return 1 if x can be represented as an 
 *  n-bit, two's complement integer.
 *   1 &lt;= n &lt;= 32
 *   Examples: fitsBits(5,3) = 0, fitsBits(-4,3) = 1
 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 15
 *   Rating: 2
 */
int fitsBits(int x, int n) {
  /* Left shift (32 - n) bits and then right shift the same
   * Make a ^ operation with the original one
   * If stay the same the result would be 0, else non-zero
   * Stay the same meaning that x could be represented as an n-bit 
   * And ! the output as a return value
   */
  int neg_n = ~ n + 1;
  int shift = 32 + neg_n;
  int temp1 = x &lt;&lt; shift;
  int temp2 = temp1 &gt;&gt; shift;
  int temp3 = temp2 ^ x;
  int result = ! temp3;
  return result;
}
</div>
</div>

<div id="outline-container-sec-1-8" class="outline-3">
<h3 id="sec-1-8">divpwr2</h3>
<div class="outline-text-3" id="text-1-8">
/* 
 * divpwr2 - Compute x/(2^n), for 0 &lt;= n &lt;= 30
 *  Round toward zero
 *   Examples: divpwr2(15,1) = 7, divpwr2(-33,4) = -2
 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 15
 *   Rating: 2
 */
int divpwr2(int x, int n) {
  /* The actual value of 15 / 2 is 7
   * The actual value of -33 / 4 is -3
   * We need to add a patch with the one in the second situation
   * If x is negative,
   * and n is non-zero,
   * and the result has difference from the dividend,
   * then the patch is 1 and add it with the value.
   */
  int mask1 = 0x1;
  int temp1 = x &gt;&gt; 31;
  int temp2 = x &gt;&gt; n;
  int temp3 = temp2 &lt;&lt; n;
  int n_zero_or_not = ! n;
  int post_or_not = ! (temp1 &amp; mask1);
  int same_or_not = ! (x ^ temp3);
  int patch = (n_zero_or_not | post_or_not | same_or_not) ^ 0x1;
  int result = temp2 + patch;
  return result;
}
</div>
</div>

<div id="outline-container-sec-1-9" class="outline-3">
<h3 id="sec-1-9">negate</h3>
<div class="outline-text-3" id="text-1-9">
/* 
 * negate - return -x 
 *   Example: negate(1) = -1.
 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 5
 *   Rating: 2
 */
int negate(int x) {
  /* According to the law of two's complement
   * The two's complement representation of n-bit integer x is
   * 2^n + x
   * which is equal to (2^n - 1) + x + 1
   * thus the binary representation is
   * 0xfff...(n-bit) + x + 1
   * when the x is negative a more friendly form is
   * ~(-x) + 1
   * And when to compute the value of one negative integer y
   * The form would be -1 * 2^(n-1) + a_(n-2) * 2^(n-2) + ...
   * Could be changed to -(0xffff(n-1 bits f) - y(n-1 bits) + 1)
   * Top most bit of y could be treated as turning from 1 to 0
   * So a more friendly form -(~y + 1)
   * Such throry could be used to negate one of int type
   */
  int result = ~ x + 1;
  return result;
}
</div>
</div>

<div id="outline-container-sec-1-10" class="outline-3">
<h3 id="sec-1-10">isPositive</h3>
<div class="outline-text-3" id="text-1-10">
/* 
 * isPositive - return 1 if x &gt; 0, return 0 otherwise 
 *   Example: isPositive(-1) = 0.
 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 8
 *   Rating: 3
 */
int isPositive(int x) {
  /* The law is that if the value is non-zero
   * and positive, the output would be 1
   */
  int mask = 0x1;
  int temp = x &gt;&gt; 31;
  int post_or_not = ! (temp &amp; mask);
  int zero_or_not = ! (x ^ 0x0);
  int result = post_or_not &amp; (! zero_or_not);
  return result;
}
</div>
</div>

<div id="outline-container-sec-1-11" class="outline-3">
<h3 id="sec-1-11">isLessOrEqual</h3>
<div class="outline-text-3" id="text-1-11">
/* 
 * isLessOrEqual - if x &lt;= y  then return 1, else return 0 
 *   Example: isLessOrEqual(4,5) = 1.
 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 24
 *   Rating: 3
 */
int isLessOrEqual(int x, int y) {
  /* Three situations
   * 1. equal
   * 2. different symbol
   * 3. there's a need to do x - y operation
   */
  int mask = 0x1;
  /* Determine if equal */
  int equal_or_not = ! (x ^ y);
  /* Determine if x and y have different symbol */
  int x_symbol = (x &gt;&gt; 31) &amp; mask;
  int y_symbol = (y &gt;&gt; 31) &amp; mask;
  int diff_symbol = x_symbol ^ y_symbol;
  /* If so, when x is negative, x is less than y */
  int x_l_y = diff_symbol &amp; x_symbol;
  /* Operation x - y */
  int nega_y = ~ y + 1;
  int temp = x + nega_y;
  /* Determine the symbol of difference */
  int temp_nega_or_not = (temp &gt;&gt; 31) &amp; mask;
  /* Attention that with different symbol, the result only relies on x_l_y,
   * we know that they're not equal,
   * and the value of temp_nega_or_not should be screened
   */
  int result = equal_or_not | x_l_y | ((! diff_symbol) &amp; temp_nega_or_not);
  return result;
}
</div>
</div>

<div id="outline-container-sec-1-12" class="outline-3">
<h3 id="sec-1-12">ilog2</h3>
<div class="outline-text-3" id="text-1-12">
/*
 * ilog2 - return floor(log base 2 of x), where x &gt; 0
 *   Example: ilog2(16) = 4
 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 90
 *   Rating: 4
 */
int ilog2(int x) {
  /* Return floor, ilog2(16) = 4, ilog2(30) = 4, and x &gt; 0
   * When x is 2^(n-1), there is only ont bit 1 in the representation,
   * result is the left shift of 0x1 to x
   * And the result only depends on the top most bit 1
   * This simplifies the question to calculate where the top most bit 1 is
   * The return value would be its index
   */
  /* Initial index as 0 */
  int index = 0;
  /* Make masks */
  int temp_mask1 = 0x0f | (0x0f &lt;&lt; 8);
  int temp_mask2 = 0x33 | (0x33 &lt;&lt; 8);
  int temp_mask3 = 0x55 | (0x55 &lt;&lt; 8);
  int mask1 = 0xff | (0xff &lt;&lt; 8);
  int mask2 = 0xff | (0xff &lt;&lt; 16);
  int mask3 = temp_mask1 | (temp_mask1 &lt;&lt; 16);
  int mask4 = temp_mask2 | (temp_mask2 &lt;&lt; 16);
  int mask5 = temp_mask3 | (temp_mask3 &lt;&lt; 16);
  /* Use mask1 0x0000ffff to screen x,
   * determine whether there's a difference
   * between the original one and screened one
   * The main purpose is to get where the top most bit 1 is,
   * in the higher 16 bits section or the lower?
   * Then the index equals to the start index of the section
   */
  int masked_x_1 = x &amp; mask1;
  int same_or_not_1 = ! (masked_x_1 ^ x);
  int section_start_1 = 16 &gt;&gt; (same_or_not_1 &lt;&lt; 3);
  index = index + section_start_1;
  /* If not staying same after ^, remove the lower 16 bits section
   * else x is kept unchaged
   */
  int left_1 = (x &gt;&gt; index) &lt;&lt; index;
  /* Almost same procedure to deal with the left part */
  int masked_x_2 = left_1 &amp; mask2;
  int same_or_not_2 = ! (masked_x_2 ^ left_1);
  int section_start_2 = 8 &gt;&gt; (same_or_not_2 &lt;&lt; 2);
  index = index + section_start_2;
  int left_2 = (left_1 &gt;&gt; index) &lt;&lt; index;

  int masked_x_3 = left_2 &amp; mask3;
  int same_or_not_3 = ! (masked_x_3 ^ left_2);
  int section_start_3 = 4 &gt;&gt; (same_or_not_3 &lt;&lt; 2);
  index = index + section_start_3;
  int left_3 = (left_2 &gt;&gt; index) &lt;&lt; index;

  int masked_x_4 = left_3 &amp; mask4;
  int same_or_not_4 = ! (masked_x_4 ^ left_3);
  int section_start_4 = 2 &gt;&gt; (same_or_not_4 &lt;&lt; 1);
  index = index + section_start_4;
  int left_4 = (left_3 &gt;&gt; index) &lt;&lt; index;

  int masked_x_5 = left_4 &amp; mask5;
  int same_or_not_5 = ! (masked_x_5 ^ left_4);
  int section_start_5 = 1 &gt;&gt; (same_or_not_5 &lt;&lt; 1);
  index = index + section_start_5;

  return index;
}
</div>
</div>

<div id="outline-container-sec-1-13" class="outline-3">
<h3 id="sec-1-13">float<sub>neg</sub>
</h3>
<div class="outline-text-3" id="text-1-13">
/* 
 * float_neg - Return bit-level equivalent of expression -f for
 *   floating point argument f.
 *   Both the argument and result are passed as unsigned int's, but
 *   they are to be interpreted as the bit-level representations of
 *   single-precision floating point values.
 *   When argument is NaN, return argument.
 *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while
 *   Max ops: 10
 *   Rating: 2
 */
unsigned float_neg(unsigned uf) {
  /* Other than NaN, top most bit of argument should be inversed
   * NaN reamins unchanged as a return value
   */
  /* Get the part exponent */
  unsigned exponent = (uf &lt;&lt; 1) &gt;&gt; 24;
  /* Get the part fraction */
  unsigned fraction = uf &lt;&lt; 9;
  unsigned is_exponent_full_1 = ! (exponent ^ 0xff);
  /* Determine if this value a NaN */
  unsigned is_NaN_or_not = is_exponent_full_1 &amp;&amp; fraction;
  /* If uf a NaN, keep it unchanged, else inverse the top most bit */
  unsigned result = uf + ((! is_NaN_or_not) &lt;&lt; 31);
  return result;
}
</div>
</div>

<div id="outline-container-sec-1-14" class="outline-3">
<h3 id="sec-1-14">float<sub>i2f</sub>
</h3>
<div class="outline-text-3" id="text-1-14">
/* 
 * float_i2f - Return bit-level equivalent of expression (float) x
 *   Result is returned as unsigned int, but
 *   it is to be interpreted as the bit-level representation of a
 *   single-precision floating point values.
 *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while
 *   Max ops: 30
 *   Rating: 4
 */
unsigned float_i2f(int x) {
  /* First determine the exponent bias based on the value x
   * Then keep the symbol of x, get the alsolute value of x
   * Then determine the index of left most 1 of the abs x,
   * that index plus bias is the exponent of the single float
   * Left shifted that clears all left zero bits of abs x
   * right shifted and masked that leave 9 slots for symbol and exponent,
   * see that if the lost part equals or greater than 128,
   * two situations: greater; equal and the last bit of shifted vaule is 1,
   * both that the shifted vaule should plus 1
   * Determine if there's a bit 1 in index 23,
   * if so, fraction is 0 and exponent increases by 1
   */
  /* Determine the bias */
  unsigned exponent_bias = 0;
  if(x)
    {
      exponent_bias = 0x7f;
    }
  /* Get the symbol and abs of x */
  unsigned symbol = x &amp; 0x80000000;
  unsigned x_absoulte = x;
  if(symbol)
    {
      x_absoulte = ~ x + 1;
    }
  /* A while loop to right shift abs x by 1 until the value is 0,
   * record the shifted setps, which is index of top most bit 1
   */
  int index = 0;
  unsigned temp = x_absoulte;
  while(temp)
    {
      temp = temp &gt;&gt; 1;
      index = index + (temp &amp;&amp; 0x1);
    }
  /* Calculate exponent and left shift setps that could clear left 0 bits */
  unsigned exponent = index + exponent_bias;
  int left_shift = 31 + (~ index + 1);
  unsigned fraction = x_absoulte &lt;&lt; left_shift;
  /* Keep the lost part */
  unsigned tail = fraction &amp; 0xff;
  /* Leave 9 slots for symbol and exponent */
  fraction = (fraction &gt;&gt; 8) &amp; 0x7fffff;
  /* Determine if it's necessary to increase fraction by 1
   * If greater than 0.5, increment;
   * equals to 0.5 and the last bit is 1, increment, round up to even
   */
  int tail_7th_bit = tail &amp; 0x80;
  int tail_left_bits = tail &amp; 0x7f;
  int tail_l_128 = tail_7th_bit &amp;&amp; tail_left_bits;
  fraction = fraction + (tail_l_128 || (tail_7th_bit &amp;&amp; (fraction &amp; 1)));
  /* Determine if fraction has a carry after a possible increment
   * if so, fraction is 0 and exponent increases by 1
   */
  if(fraction &gt;&gt; 23)
    {
      fraction = 0;
      exponent = exponent + 1;
    }
  unsigned result = symbol | (exponent &lt;&lt; 23) | fraction;
  return result;
}
</div>
</div>

<div id="outline-container-sec-1-15" class="outline-3">
<h3 id="sec-1-15">float<sub>twice</sub>
</h3>
<div class="outline-text-3" id="text-1-15">
/* 
 * float_twice - Return bit-level equivalent of expression 2*f for
 *   floating point argument f.
 *   Both the argument and result are passed as unsigned int's, but
 *   they are to be interpreted as the bit-level representation of
 *   single-precision floating point values.
 *   When argument is NaN, return argument
 *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while
 *   Max ops: 30
 *   Rating: 4
 */
unsigned float_twice(unsigned uf) {
  /* Four special cases: NaN, infinite, zero, non-normalized,
   * return it self if uf meets first three cases,
   * for non-normalized, be careful that
   * it may become a normalized single float when doubled
   */
  /* Get the part exponent */
  unsigned exponent = (uf &lt;&lt; 1) &gt;&gt; 24;
  /* Get the part fraction */
  unsigned fraction = uf &amp; 0x7fffff;
  unsigned exponent_full_1 = ! (exponent ^ 0xff);
  /* Determine type of this value */
  unsigned NaN_or_not = exponent_full_1 &amp;&amp; fraction;
  unsigned infinite_or_not = exponent_full_1 &amp;&amp; (! fraction);
  unsigned zero_or_not = ! (uf &amp; 0x7fffffff);
  unsigned not_normalized_or_not = (! exponent) &amp;&amp; fraction;
  /* If meeting the first three cases, return it self */
  if(NaN_or_not || infinite_or_not || zero_or_not)
    {
      return uf;
    }
  /* If uf a non-normalized single float, check the fraction part */
  if(not_normalized_or_not)
    {
      unsigned temp_fraction = fraction &lt;&lt; 1;
      fraction = temp_fraction &amp; 0x7fffff;
      /* That if there's a carry of 1 */
      if(temp_fraction &amp; 0x800000)
	{
	  /* The value of non-normalized is (-1)^(s) * 0.xxx * 2^(-126),
	   * the exponent is always -126 implicitly;
	   * Now make the exponent 0x1, make it -126 explicitly
	   */
	  return (uf &amp; 0x80000000) | 0x00800000 | fraction;
	}
      /* If no carry, just change the fraction */
      return (uf &amp; 0xff800000) | fraction;
    }
  /* Notice that if the original exponent is 0xfe
   * double f would make exponent 0xff
   * with such a exponent and a non-zero fraction
   * the return value is a NaN
   * it's out of the single float representation range
   */
  return uf + 0x00800000;
}
</div>
</div>
</div>
    </div>
    <div class="postmeta">
    <small> § 
        <span class="dateline"><a href="." rel="bookmark"><time class="published dt-published" datetime="2018-01-28T19:40:04+08:00" itemprop="datePublished" title="Publication date">2018-01-28 19:40</time></a></span>
    </small>
        · 
        
    <a href="#disqus_thread" data-disqus-identifier="cache/posts/csapp-datalab-jie-ti-si-lu-ji-lu.html">Comments</a>


         · csapp lab c
    </div>

        
        
        <div id="disqus_thread"></div>
        <script>
        var disqus_shortname ="https-zero4drift-github-io",
            disqus_url="https://zero4drift.github.io/posts/csapp-datalab-jie-ti-si-lu-ji-lu/",
        disqus_title="CSAPP-datalab \u89e3\u9898\u601d\u8def\u8bb0\u5f55",
        disqus_identifier="cache/posts/csapp-datalab-jie-ti-si-lu-ji-lu.html",
        disqus_config = function () {
            this.language = "en";
        };
        (function() {
            var dsq = document.createElement('script'); dsq.async = true;
            dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
</noscript>
    <a href="https://disqus.com" class="dsq-brlink" rel="nofollow">Comments powered by <span class="logo-disqus">Disqus</span></a>



    </div>
    <div class="row-fluid">
        <div class="span6" style="text-align: right; border-right: 2px solid #ccc; padding-right: 20px;">
            <ul class="unstyled bottom">
<li>
<a href="../../archive.html">Archive</a>
                        </li>
<li>
<a href="https://github.com/zero4drift">Github</a>
                        </li>
<li>
<a href="../../categories/">Tags</a>
                        </li>
<li>
<a href="../../rss.xml">RSS feed</a>
                
            </li>
</ul>
</div>
        <div class="span6" style="margin-left: 20px;">
            <ul class="unstyled bottom">
<li>Shares: <div id="share"></div>
</li>
            </ul>
<div>
            
            </div>
        </div>
    </div>
    <hr>
<div class="footer">
    Contents © 2018         <a href="mailto:fang0052@e.ntu.edu.sg">zero4drift</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         
    
    </div>
</div>
    
            <script src="../../assets/js/all-nocdn.js"></script><script type="text/javascript" src="../../assets/js/jquery.sharrre-1.3.4.min.js"></script><script type="text/javascript">
        jQuery("a.image-reference").colorbox({rel:"gal",maxWidth:"80%",maxHeight:"80%",scalePhotos:true});
        $('#share').sharrre({
        share: {
            googlePlus: true,
            twitter: true
        },
        buttons: {
            googlePlus: {annotation:'bubble'},
            twitter: {count: 'horizontal'}
        },
        hover: function(api, options){
            $(api.element).find('.buttons').show();
        },
        hide: function(api, options){
            $(api.element).find('.buttons').hide();
        },
        enableTracking: true,
        urlCurl: ""
        });
    </script><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-112733609-1"></script><script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-112733609-1');
</script>
</body>
</html>
