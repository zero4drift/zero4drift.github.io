<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " vocab="http://ogp.me/ns" lang="en">
<head>
<meta charset="utf-8">
<meta name="description" content="Cpp Primer 5th answers chapter-13 Exercises">
<meta name="viewport" content="width=device-width">
<title>Cpp-Primer-5th-Exercises-Chapter-13 | Procrastination Prescription</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<link rel="alternate" type="application/rss+xml" title="RSS" href="../../rss.xml">
<link rel="canonical" href="https://zero4drift.github.io/posts/Cpp-Primer-5th-Exercises-Chapter-13/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="zero4drift">
<meta property="og:site_name" content="Procrastination Prescription">
<meta property="og:title" content="Cpp-Primer-5th-Exercises-Chapter-13">
<meta property="og:url" content="https://zero4drift.github.io/posts/Cpp-Primer-5th-Exercises-Chapter-13/">
<meta property="og:description" content="Cpp Primer 5th answers chapter-13 Exercises">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2018-06-29T19:39:56+08:00">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="cpp-primer">
</head>
<body>
    

    <header id="header" class="navbar"><div class="container">
            
    <div class="brand">

        <div class="brand-text">
            <a href="https://zero4drift.github.io/" title="Procrastination Prescription" rel="home">
                Procrastination Prescription
            </a>
        </div>

        <a id="btn-toggle-nav" class="navbar-toggle">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </a>
    </div>

            
    <nav class="navbar-collapse collapse"><ul class="nav">
<li><a href="../../archive.html">Archive</a></li>
                <li><a href="https://github.com/zero4drift">Github</a></li>
                <li><a href="../../categories/">Tags</a></li>
                <li><a href="../../rss.xml">RSS feed</a></li>
    
    
    </ul></nav>
</div>
    </header><div class="header-padding"> </div>

    
    <div class="post-header">
        <div class="container">
            <div class="title">
                Cpp-Primer-5th-Exercises-Chapter-13
            </div>
        </div>
    </div>

    <div class="post-meta">
      <div class="container">
	<div class="meta clearfix">
	  <div class="authordate">
	    <time class="timeago" datetime="2018-06-29T19:39:56+08:00">2018/06/29</time>
</div>
	  <div class="post-tags">
	    <div class="tag">
	      <a href="../../categories/c%2B%2B/" rel="tag">C++</a>
	    </div>
	    <div class="tag">
	      <a href="../../categories/cpp-primer/" rel="tag">cpp-primer</a>
	    </div>
	  </div>
	</div>
      </div>
    </div>
    
    
    <div id="post-main" class="main">
        <div class="container">
        <div id="outline-container-orgadb459e" class="outline-2">
<h2 id="orgadb459e">Exercise 13.1</h2>
<div class="outline-text-2" id="text-orgadb459e">
<div class="highlight"><pre><span></span><span class="c1">// Within a class type, if the first parameter of one constructor is the reference of the class type itself, and left parameters all have default values, then this constrcutor is copy constructor.</span>
<span class="c1">// copy constructor is utilized in copy initialization:</span>
<span class="c1">// 1. Define variable using an =;</span>
<span class="c1">// 2. Pass an object as an argument to a parameter of noreference type;</span>
<span class="c1">// 3. Return an object from a function that has a nonreference return type;</span>
<span class="c1">// 4. Brace initialize the elements in an array or the members of an aggregate class;</span>
<span class="c1">// 5. Some class types also use copy initializetion for the objects they allocate.</span>
</pre></div>
</div>
</div>

<div id="outline-container-org281ae02" class="outline-2">
<h2 id="org281ae02">Exercise 13.2</h2>
<div class="outline-text-2" id="text-org281ae02">
<div class="highlight"><pre><span></span><span class="c1">// Sales_data::Sales_data(Sales_data rhs)</span>
<span class="c1">// try to define a copy constructor of class type Sales_data;</span>
<span class="c1">// and the first parameter's type is Sales_data, it is illegal;</span>
<span class="c1">// when copy constructor is used in copy initialization, Sales_data object as argument is pass in to copy initialize the paramenter rhs;</span>
<span class="c1">// while this copy initialize will call the copy constructor itself;</span>
<span class="c1">// a infinite loop in the end;</span>
<span class="c1">// so the type of first parameter should be Sales_data&amp;.</span>
</pre></div>
</div>
</div>

<div id="outline-container-org80afc38" class="outline-2">
<h2 id="org80afc38">Exercise 13.3</h2>
<div class="outline-text-2" id="text-org80afc38">
<div class="highlight"><pre><span></span><span class="c1">// copy a StrBlob object would copy every non-static member of it, and StrBlob class type has a shared_ptr member, copy it will increase the reference count of the object which is pointed by shared_ptr.</span>
<span class="c1">// copy a StrBlob object would copy every non-static member of it, StrBlobPtr class type has a weak_ptr member, copy it will not influence the reference count of the object which is pointed by weak_ptr.</span>
</pre></div>
</div>
</div>

<div id="outline-container-org88240b5" class="outline-2">
<h2 id="org88240b5">Exercise 13.4</h2>
<div class="outline-text-2" id="text-org88240b5">
<div class="highlight"><pre><span></span><span class="n">Point</span> <span class="n">global</span><span class="p">;</span>
<span class="n">Point</span> <span class="nf">foo_var</span><span class="p">(</span><span class="n">Point</span> <span class="n">arg</span><span class="p">)</span>	<span class="c1">// argument passed in would call copy constructor </span>
<span class="p">{</span>
  <span class="n">Point</span> <span class="n">local</span> <span class="o">=</span> <span class="n">arg</span><span class="p">,</span> <span class="o">*</span><span class="n">heap</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Point</span><span class="p">(</span><span class="n">global</span><span class="p">);</span> <span class="c1">// call copy constructor twice.</span>
  <span class="o">*</span><span class="n">heap</span> <span class="o">=</span> <span class="n">local</span><span class="p">;</span>				<span class="c1">// copy-assignment operator</span>
  <span class="n">Point</span> <span class="n">pa</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">local</span><span class="p">,</span> <span class="o">*</span><span class="n">heap</span><span class="p">};</span>			<span class="c1">// use curly braced list to initialize array would call copy constructor</span>
  <span class="k">return</span> <span class="o">*</span><span class="n">heap</span><span class="p">;</span>					<span class="c1">// return an object, and the return type of this function is not reference, then it calls copy constructor</span>
<span class="p">}</span>
</pre></div>
</div>
</div>

<div id="outline-container-org950f0fb" class="outline-2">
<h2 id="org950f0fb">Exercise 13.5</h2>
<div class="outline-text-2" id="text-org950f0fb">
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">HasPtr</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">HasPtr</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span> <span class="o">=</span> <span class="n">string</span><span class="p">())</span><span class="o">:</span>
    <span class="n">ps</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="n">s</span><span class="p">)),</span> <span class="n">i</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
  <span class="n">HasPtr</span><span class="p">(</span><span class="k">const</span> <span class="n">HasPtr</span> <span class="o">&amp;</span><span class="n">h</span><span class="p">)</span><span class="o">:</span> <span class="n">ps</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="o">*</span><span class="n">h</span><span class="p">.</span><span class="n">ps</span><span class="p">)),</span> <span class="n">i</span><span class="p">(</span><span class="n">h</span><span class="p">.</span><span class="n">i</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">private</span><span class="o">:</span>
  <span class="n">string</span> <span class="o">*</span><span class="n">ps</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</div>

<div id="outline-container-orga85786a" class="outline-2">
<h2 id="orga85786a">Exercise 13.6</h2>
<div class="outline-text-2" id="text-orga85786a">
<div class="highlight"><pre><span></span><span class="c1">// copy-assignment operator defines what happened when assign an object to another object with same type.</span>
<span class="c1">// when assign an object to another object with same type, copy-assignment operator would be called.</span>
<span class="c1">// for sone class type, copy-assignment operator prevents the assignment of objects of this calss type, but mainly copy-assignment operator would assign every non-static member of right operand to the corresponding member of left operand using the copy-assignment operator for the type of the member.</span>
<span class="c1">// if there is no copy-assignment operator defined within a class type, compiler would generate a synthesized copy-assignment oeperator for it.</span>
</pre></div>
</div>
</div>

<div id="outline-container-orgac78a9e" class="outline-2">
<h2 id="orgac78a9e">Exercise 13.7</h2>
<div class="outline-text-2" id="text-orgac78a9e">
<div class="highlight"><pre><span></span><span class="c1">// assign a StrBlob object to another StrBlob object would assign every non-static member of it, and StrBlob class type has a shared_ptr member, assign it will increase the reference count of the object which is pointed by right operand's shared_ptr, and decrease the reference count of the object which is pointed by the left operand's shared_ptr .</span>
<span class="c1">// assign a StrBlobPtr object to another StrBlobPtr object would assign every non-static member of it, StrBlobPtr class type has a weak_ptr member, assignment of it will not influence the reference count of the object which is pointed by weak_ptr.</span>
</pre></div>
</div>
</div>

<div id="outline-container-orga9b0cc7" class="outline-2">
<h2 id="orga9b0cc7">Exercise 13.8</h2>
<div class="outline-text-2" id="text-orga9b0cc7">
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">HasPtr</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">HasPtr</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">())</span><span class="o">:</span>
    <span class="n">ps</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="n">s</span><span class="p">)),</span> <span class="n">i</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
  <span class="n">HasPtr</span><span class="p">(</span><span class="k">const</span> <span class="n">HasPtr</span> <span class="o">&amp;</span><span class="n">h</span><span class="p">)</span><span class="o">:</span> <span class="n">ps</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span><span class="p">),</span> <span class="n">i</span><span class="p">(</span><span class="n">h</span><span class="p">.</span><span class="n">i</span><span class="p">)</span> <span class="p">{}</span>
  <span class="n">HasPtr</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">HasPtr</span> <span class="o">&amp;</span><span class="p">);</span>
<span class="k">private</span><span class="o">:</span>
  <span class="n">string</span> <span class="o">*</span><span class="n">ps</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">HasPtr</span><span class="o">&amp;</span> <span class="n">HasPtr</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">HasPtr</span> <span class="o">&amp;</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">auto</span> <span class="n">newptr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="o">*</span><span class="n">h</span><span class="p">.</span><span class="n">ps</span><span class="p">);</span>
  <span class="k">delete</span> <span class="n">ps</span><span class="p">;</span>
  <span class="n">ps</span> <span class="o">=</span> <span class="n">newptr</span><span class="p">;</span>
  <span class="n">i</span> <span class="o">=</span> <span class="n">h</span><span class="p">.</span><span class="n">i</span><span class="p">;</span>
  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>

<div id="outline-container-org8469854" class="outline-2">
<h2 id="org8469854">Exercise 13.9</h2>
<div class="outline-text-2" id="text-org8469854">
<div class="highlight"><pre><span></span><span class="c1">// A destructor is a member function of class type, its name is combined of ~ and class name, and no return value, no parameter.</span>
<span class="c1">// destructor releases the resource used by object, destruct every non-static member of object.</span>
<span class="c1">// compiler would generate a synthesized destructor for a class if it has not defined a destructor.</span>
</pre></div>
</div>
</div>

<div id="outline-container-orgec12ac4" class="outline-2">
<h2 id="orgec12ac4">Exercise 13.10</h2>
<div class="outline-text-2" id="text-orgec12ac4">
<div class="highlight"><pre><span></span><span class="c1">// When a StrBlob object is destructed, every non-static member of it would be destructed, and descrease the reference count of the object which is pointed by object's share_ptr, if count comes to zero, that object be pointed is destructed, too.</span>
<span class="c1">// When StrBlobPtr object is destructed, every non-static member of it would be destructed, since it has a weak_ptr member, this ptr's destruction has no influence on the reference count of the object which is pointed by weak_ptr.</span>
</pre></div>
</div>
</div>

<div id="outline-container-orgca938df" class="outline-2">
<h2 id="orgca938df">Exercise 13.11</h2>
<div class="outline-text-2" id="text-orgca938df">
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">HasPtr</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">HasPtr</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span> <span class="o">=</span> <span class="n">string</span><span class="p">())</span><span class="o">:</span>
    <span class="n">ps</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="n">s</span><span class="p">)),</span> <span class="n">i</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
  <span class="n">HasPtr</span><span class="p">(</span><span class="k">const</span> <span class="n">HasPtr</span> <span class="o">&amp;</span><span class="n">h</span><span class="p">)</span><span class="o">:</span> <span class="n">ps</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="o">*</span><span class="n">h</span><span class="p">.</span><span class="n">ps</span><span class="p">)),</span> <span class="n">i</span><span class="p">(</span><span class="n">h</span><span class="p">.</span><span class="n">i</span><span class="p">)</span> <span class="p">{}</span>
  <span class="n">HasPtr</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">HasPtr</span> <span class="o">&amp;</span><span class="p">);</span>
  <span class="o">~</span><span class="n">HasPtr</span><span class="p">()</span> <span class="p">{</span><span class="k">delete</span> <span class="n">ps</span><span class="p">;};</span>
<span class="k">private</span><span class="o">:</span>
  <span class="n">string</span> <span class="o">*</span><span class="n">ps</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">HasPtr</span><span class="o">&amp;</span> <span class="n">HasPtr</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">HasPtr</span> <span class="o">&amp;</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">auto</span> <span class="n">newptr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="o">*</span><span class="n">h</span><span class="p">.</span><span class="n">ps</span><span class="p">);</span>
  <span class="k">delete</span> <span class="n">ps</span><span class="p">;</span>
  <span class="n">ps</span> <span class="o">=</span> <span class="n">newptr</span><span class="p">;</span>
  <span class="n">i</span> <span class="o">=</span> <span class="n">h</span><span class="p">.</span><span class="n">i</span><span class="p">;</span>
  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>

<div id="outline-container-org6a6829a" class="outline-2">
<h2 id="org6a6829a">Exercise 13.12</h2>
<div class="outline-text-2" id="text-org6a6829a">
<div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">fcn</span><span class="p">(</span><span class="k">const</span> <span class="n">Sales_data</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="n">Sales_data</span> <span class="n">accum</span><span class="p">)</span> <span class="c1">// accum is copy initialized within this function body, it would be destructed when this function call ends.</span>
<span class="p">{</span>
  <span class="n">Sales_data</span> <span class="n">item1</span><span class="p">(</span><span class="o">*</span><span class="n">trans</span><span class="p">),</span> <span class="n">item2</span><span class="p">(</span><span class="n">accum</span><span class="p">);</span> <span class="c1">// both would be destructed when this function body ends</span>
  <span class="k">return</span> <span class="n">item1</span><span class="p">.</span><span class="n">isbn</span><span class="p">()</span> <span class="o">!=</span> <span class="n">item2</span><span class="p">.</span><span class="n">isbn</span><span class="p">();</span> <span class="c1">// the two string temp object would be destructed when the expression ends </span>
  <span class="c1">// and the temp bool object as result of this expression would be destructed after copy initialization of the return value.</span>
<span class="p">}</span>
<span class="c1">// since destruction of Sales_data object would lead to the destruction of the string type member, and destruct string object would call its destructor.</span>
<span class="c1">// so there would be 2 + 2 + 2 + 1 + 1 = 8 times of calling of destructor.</span>
</pre></div>
</div>
</div>

<div id="outline-container-org0348860" class="outline-2">
<h2 id="org0348860">Exercise 13.13</h2>
<div class="outline-text-2" id="text-org0348860">
<div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">X</span>
<span class="p">{</span>
  <span class="n">X</span><span class="p">()</span> <span class="p">{</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"X()"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;}</span>
  <span class="n">X</span><span class="p">(</span><span class="k">const</span> <span class="n">X</span> <span class="o">&amp;</span><span class="p">)</span> <span class="p">{</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"X(const X &amp;)"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;}</span>
  <span class="n">X</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">X</span> <span class="o">&amp;</span><span class="p">)</span> <span class="p">{</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"X &amp;operator=(const X &amp;x)"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;}</span>
  <span class="o">~</span><span class="n">X</span><span class="p">()</span> <span class="p">{</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"~X()"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;}</span>
<span class="p">};</span>
<span class="kt">void</span> <span class="nf">test1</span><span class="p">(</span><span class="n">X</span> <span class="o">&amp;</span><span class="p">)</span> <span class="p">{}</span>
<span class="kt">void</span> <span class="nf">test2</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="p">{}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">X</span> <span class="n">x1</span><span class="p">;</span>
  <span class="n">X</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">x1</span><span class="p">;</span>
  <span class="n">X</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">X</span><span class="p">;</span>
  <span class="n">test1</span><span class="p">(</span><span class="n">x1</span><span class="p">);</span>
  <span class="n">test2</span><span class="p">(</span><span class="n">x1</span><span class="p">);</span>
  <span class="n">X</span> <span class="n">ax</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">};</span>
  <span class="k">delete</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>

<div id="outline-container-org7675ceb" class="outline-2">
<h2 id="org7675ceb">Exercise 13.14</h2>
<div class="outline-text-2" id="text-org7675ceb">
<div class="highlight"><pre><span></span><span class="c1">// Using synthesized copy constructor</span>
<span class="c1">// the outputs are all the same.</span>
</pre></div>
</div>
</div>

<div id="outline-container-orgfc950ca" class="outline-2">
<h2 id="orgfc950ca">Exercise 13.15</h2>
<div class="outline-text-2" id="text-orgfc950ca">
<div class="highlight"><pre><span></span><span class="c1">// if a copy constructor is defined within class type numbered,</span>
<span class="c1">// outputs would be changed, for that copy constructor would generage a new number for the object,</span>
<span class="c1">// what's more, function accepts a 'numbered s' type parameter, this would call copy instructor when called, and 's.mysn' is different from the argument passed in,</span>
<span class="c1">// different outputs, and not expected, do not match the real mysn member of original objects.</span>
</pre></div>
</div>
</div>

<div id="outline-container-org6f3f50b" class="outline-2">
<h2 id="org6f3f50b">Exercise 13.16</h2>
<div class="outline-text-2" id="text-org6f3f50b">
<div class="highlight"><pre><span></span><span class="c1">// That would give the expected result.</span>
<span class="c1">// outputs would have three different serial numbers,</span>
<span class="c1">// and every one represents the real mysn member of the passed in numbered type object.</span>
</pre></div>
</div>
</div>

<div id="outline-container-org90c9667" class="outline-2">
<h2 id="org90c9667">Exercise 13.17</h2>
<div class="outline-text-2" id="text-org90c9667">
<div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">numbered1</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">mysn</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">numbered2</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">mysn</span><span class="p">;</span>
  <span class="n">numbered2</span><span class="p">(</span><span class="k">const</span> <span class="n">numbered2</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">)</span><span class="o">:</span> <span class="n">mysn</span><span class="p">(</span><span class="n">n</span><span class="p">.</span><span class="n">mysn</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{}</span>
  <span class="n">numbered2</span><span class="p">()</span><span class="o">:</span> <span class="n">mysn</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>
<span class="kt">void</span> <span class="nf">f1</span><span class="p">(</span><span class="n">numbered1</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">mysn</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;}</span>
<span class="kt">void</span> <span class="nf">f2</span><span class="p">(</span><span class="n">numbered2</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">mysn</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;}</span>
<span class="kt">void</span> <span class="nf">f3</span><span class="p">(</span><span class="k">const</span> <span class="n">numbered2</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">mysn</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// first</span>
  <span class="n">numbered1</span> <span class="n">a1</span><span class="p">,</span> <span class="n">b1</span> <span class="o">=</span> <span class="n">a1</span><span class="p">,</span> <span class="n">c1</span> <span class="o">=</span> <span class="n">b1</span><span class="p">;</span>
  <span class="n">f1</span><span class="p">(</span><span class="n">a1</span><span class="p">);</span>
  <span class="n">f1</span><span class="p">(</span><span class="n">b1</span><span class="p">);</span>
  <span class="n">f1</span><span class="p">(</span><span class="n">c1</span><span class="p">);</span>
  <span class="c1">// second</span>
  <span class="n">numbered2</span> <span class="n">a2</span><span class="p">,</span> <span class="n">b2</span> <span class="o">=</span> <span class="n">a2</span><span class="p">,</span> <span class="n">c2</span> <span class="o">=</span> <span class="n">b2</span><span class="p">;</span>
  <span class="n">f2</span><span class="p">(</span><span class="n">a2</span><span class="p">);</span>
  <span class="n">f2</span><span class="p">(</span><span class="n">b2</span><span class="p">);</span>
  <span class="n">f2</span><span class="p">(</span><span class="n">c2</span><span class="p">);</span>
  <span class="c1">// third</span>
  <span class="n">f3</span><span class="p">(</span><span class="n">a2</span><span class="p">);</span>
  <span class="n">f3</span><span class="p">(</span><span class="n">b2</span><span class="p">);</span>
  <span class="n">f3</span><span class="p">(</span><span class="n">c2</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>

<div id="outline-container-org95d17c6" class="outline-2">
<h2 id="org95d17c6">Exercise 13.18</h2>
<div class="outline-text-2" id="text-org95d17c6">
<div class="highlight"><pre><span></span><span class="c1">// See Employee.h</span>
</pre></div>
</div>
</div>

<div id="outline-container-org0757004" class="outline-2">
<h2 id="org0757004">Employee.h</h2>
<div class="outline-text-2" id="text-org0757004">
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Employee</span>
<span class="p">{</span>
  <span class="k">static</span> <span class="kt">unsigned</span> <span class="n">seed</span><span class="p">;</span>
  <span class="n">string</span> <span class="n">name</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
 <span class="k">public</span><span class="o">:</span>
 <span class="n">Employee</span><span class="p">()</span><span class="o">:</span> <span class="n">id</span><span class="p">(</span><span class="o">++</span><span class="n">seed</span><span class="p">)</span> <span class="p">{}</span>
 <span class="n">Employee</span><span class="p">(</span><span class="n">string</span> <span class="n">n</span><span class="p">)</span><span class="o">:</span> <span class="n">name</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">id</span><span class="p">(</span><span class="o">++</span><span class="n">seed</span><span class="p">)</span> <span class="p">{}</span>
 <span class="n">Employee</span><span class="p">(</span><span class="k">const</span> <span class="n">Employee</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">)</span><span class="o">:</span> <span class="n">name</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">name</span><span class="p">),</span> <span class="n">id</span><span class="p">(</span><span class="o">++</span><span class="n">seed</span><span class="p">)</span> <span class="p">{}</span>
  <span class="n">Employee</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Employee</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">);</span>
<span class="p">};</span>
<span class="kt">unsigned</span> <span class="n">Employee</span><span class="o">::</span><span class="n">seed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">Employee</span><span class="o">&amp;</span> <span class="n">Employee</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Employee</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">name</span> <span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
  <span class="n">id</span> <span class="o">=</span> <span class="o">++</span><span class="n">seed</span><span class="p">;</span>
  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>

<div id="outline-container-org46b6897" class="outline-2">
<h2 id="org46b6897">Exercise 13.19</h2>
<div class="outline-text-2" id="text-org46b6897">
<div class="highlight"><pre><span></span><span class="c1">// Should define copy constructor and copy assignment operator itself.</span>
<span class="c1">// For the name may be the same, but id of every employee object should be unique(id should be handled automatically) </span>
<span class="c1">// See Employee.h</span>
</pre></div>

<p>
<a href="#org0757004">Employee.h</a>
</p>
</div>
</div>

<div id="outline-container-org33673f9" class="outline-2">
<h2 id="org33673f9">Exercise 13.20</h2>
<div class="outline-text-2" id="text-org33673f9">
<div class="highlight"><pre><span></span><span class="c1">// copy: copy TextQuery or QueryResult object would copy every mamber of it, and would increase the reference count of the object which is pointed by the shared_ptr member;</span>
<span class="c1">// assignment: assign TextQuery or QueryResult object would assign every mamber of it, and would increase the reference count of the object which is pointed by the shared_ptr member, decrease the reference count of the object which is pointed by the original shared_ptr;</span>
<span class="c1">// destruct: destruct TextQuery or QueryResult object would destruct every mamber of it, and would decrease the reference count of the object which is pointed by the shared_ptr member;</span>
</pre></div>
</div>
</div>

<div id="outline-container-org519e694" class="outline-2">
<h2 id="org519e694">Exercise 13.21</h2>
<div class="outline-text-2" id="text-org519e694">
<div class="highlight"><pre><span></span><span class="c1">// Should define the copy constructor and copy assignment operator;</span>
<span class="c1">// copy objects of both types should just copy the content pointed by the share_ptr to another memory space pointed by the new shared_ptr, not directly copy the share_ptr object.</span>
<span class="c1">// See TextQuery.h</span>
</pre></div>
</div>
</div>

<div id="outline-container-orgac04472" class="outline-2">
<h2 id="orgac04472">TextQuery.h</h2>
<div class="outline-text-2" id="text-orgac04472">
<div class="highlight"><pre><span></span><span class="cp">#ifndef TEXTQUERY_H</span>
<span class="cp">#define TEXTQUERY_H</span>
<span class="k">class</span> <span class="nc">QueryResult</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">TextQuery</span>
<span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="k">using</span> <span class="n">line_no</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;::</span><span class="n">size_type</span><span class="p">;</span>
  <span class="n">TextQuery</span><span class="p">(</span><span class="n">ifstream</span> <span class="o">&amp;</span><span class="n">infile</span><span class="p">);</span>
  <span class="n">TextQuery</span><span class="p">(</span><span class="k">const</span> <span class="n">TextQuery</span> <span class="o">&amp;</span><span class="p">);</span>
  <span class="n">TextQuery</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">TextQuery</span> <span class="o">&amp;</span><span class="p">);</span>
  <span class="n">QueryResult</span> <span class="nf">query</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
 <span class="k">private</span><span class="o">:</span>
  <span class="k">friend</span> <span class="n">QueryResult</span><span class="p">;</span>
  <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">sp1</span><span class="p">;</span>
  <span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">set</span><span class="o">&lt;</span><span class="n">line_no</span><span class="o">&gt;&gt;&gt;</span> <span class="n">mp</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">TextQuery</span><span class="o">::</span><span class="n">TextQuery</span><span class="p">(</span><span class="n">ifstream</span> <span class="o">&amp;</span><span class="n">infile</span><span class="p">)</span><span class="o">:</span>
<span class="n">sp1</span><span class="p">(</span><span class="k">new</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">)</span>
<span class="p">{</span>  
  <span class="n">line_no</span> <span class="n">line_number</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">string</span> <span class="n">line</span><span class="p">;</span>
  <span class="k">while</span><span class="p">(</span><span class="n">getline</span><span class="p">(</span><span class="n">infile</span><span class="p">,</span> <span class="n">line</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="c1">// store line in vector&lt;string&gt;</span>
      <span class="n">sp1</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="n">line</span><span class="p">);</span>
      <span class="c1">// scan through the line      </span>
      <span class="n">istringstream</span> <span class="nf">ist</span><span class="p">(</span><span class="n">line</span><span class="p">);</span>
      <span class="n">string</span> <span class="n">word</span><span class="p">;</span>
      <span class="k">while</span><span class="p">(</span><span class="n">ist</span> <span class="o">&gt;&gt;</span> <span class="n">word</span><span class="p">)</span>
      <span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="n">ispunct</span><span class="p">(</span><span class="n">word</span><span class="p">[</span><span class="n">word</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]))</span>
	  <span class="n">word</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">word</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">auto</span> <span class="o">&amp;</span><span class="n">lines</span> <span class="o">=</span> <span class="n">mp</span><span class="p">[</span><span class="n">word</span><span class="p">];</span>
	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">lines</span><span class="p">)</span> <span class="n">lines</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <span class="n">set</span><span class="o">&lt;</span><span class="n">line_no</span><span class="o">&gt;</span><span class="p">);</span>
	<span class="n">lines</span><span class="o">-&gt;</span><span class="n">insert</span><span class="p">(</span><span class="n">line_number</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="c1">// increase the line_number</span>
      <span class="o">++</span><span class="n">line_number</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">TextQuery</span><span class="o">::</span><span class="n">TextQuery</span><span class="p">(</span><span class="k">const</span> <span class="n">TextQuery</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">)</span><span class="o">:</span> <span class="n">sp1</span><span class="p">(</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">.</span><span class="n">sp1</span><span class="p">)),</span> <span class="n">mp</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">mp</span><span class="p">)</span> <span class="p">{}</span>
<span class="n">TextQuery</span> <span class="o">&amp;</span><span class="n">TextQuery</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">TextQuery</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">sp1</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">.</span><span class="n">sp1</span><span class="p">);</span>
  <span class="n">mp</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="n">mp</span><span class="p">;</span>
  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
  <span class="k">class</span> <span class="nc">QueryResult</span>
  <span class="p">{</span>
    <span class="k">friend</span> <span class="n">ostream</span> <span class="o">&amp;</span><span class="n">print</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">QueryResult</span> <span class="o">&amp;</span><span class="p">);</span>
    <span class="n">string</span> <span class="n">search_word</span><span class="p">;</span>
    <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">sp1</span><span class="p">;</span>
    <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">set</span><span class="o">&lt;</span><span class="n">TextQuery</span><span class="o">::</span><span class="n">line_no</span><span class="o">&gt;&gt;</span> <span class="n">sp2</span><span class="p">;</span>
  <span class="k">public</span><span class="o">:</span>
  <span class="n">QueryResult</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">,</span>
	    <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">set</span><span class="o">&lt;</span><span class="n">TextQuery</span><span class="o">::</span><span class="n">line_no</span><span class="o">&gt;&gt;</span> <span class="n">p</span><span class="p">,</span>
	    <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">file</span><span class="p">)</span><span class="o">:</span> <span class="n">search_word</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">sp1</span><span class="p">(</span><span class="n">file</span><span class="p">),</span> <span class="n">sp2</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">QueryResult</span><span class="p">(</span><span class="k">const</span> <span class="n">QueryResult</span> <span class="o">&amp;</span><span class="p">);</span>
    <span class="n">QueryResult</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">QueryResult</span> <span class="o">&amp;</span><span class="p">);</span>
    <span class="n">set</span><span class="o">&lt;</span><span class="n">TextQuery</span><span class="o">::</span><span class="n">line_no</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">begin</span><span class="p">()</span> <span class="p">{</span><span class="k">return</span> <span class="n">sp2</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">();}</span>
    <span class="n">set</span><span class="o">&lt;</span><span class="n">TextQuery</span><span class="o">::</span><span class="n">line_no</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">end</span><span class="p">()</span> <span class="p">{</span><span class="k">return</span> <span class="n">sp2</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">();}</span> 
    <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">get_file</span><span class="p">()</span> <span class="p">{</span><span class="k">return</span> <span class="n">sp1</span><span class="p">;}</span>
  <span class="p">};</span>
<span class="n">QueryResult</span><span class="o">::</span><span class="n">QueryResult</span><span class="p">(</span><span class="k">const</span> <span class="n">QueryResult</span> <span class="o">&amp;</span><span class="n">q</span><span class="p">)</span><span class="o">:</span> <span class="n">sp1</span><span class="p">(</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">q</span><span class="p">.</span><span class="n">sp1</span><span class="p">)),</span> <span class="n">sp2</span><span class="p">(</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">set</span><span class="o">&lt;</span><span class="n">TextQuery</span><span class="o">::</span><span class="n">line_no</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">q</span><span class="p">.</span><span class="n">sp2</span><span class="p">)),</span> <span class="n">search_word</span><span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">search_word</span><span class="p">)</span> <span class="p">{}</span>
<span class="n">QueryResult</span> <span class="o">&amp;</span><span class="n">QueryResult</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">QueryResult</span> <span class="o">&amp;</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">sp1</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">q</span><span class="p">.</span><span class="n">sp1</span><span class="p">);</span>
  <span class="n">sp2</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="n">set</span><span class="o">&lt;</span><span class="n">TextQuery</span><span class="o">::</span><span class="n">line_no</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">q</span><span class="p">.</span><span class="n">sp2</span><span class="p">);</span>
  <span class="n">search_word</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">search_word</span><span class="p">;</span>
  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
  <span class="n">ostream</span> <span class="o">&amp;</span><span class="n">print</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">o</span><span class="p">,</span> <span class="k">const</span> <span class="n">QueryResult</span> <span class="o">&amp;</span><span class="n">q</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">auto</span> <span class="n">n</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">sp2</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">();</span>
    <span class="n">o</span> <span class="o">&lt;&lt;</span> <span class="s">"element occurs "</span> <span class="o">&lt;&lt;</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="s">" times"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="o">*</span><span class="n">q</span><span class="p">.</span><span class="n">sp2</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="nl">l</span> <span class="p">:</span> <span class="n">result</span><span class="p">)</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\t</span><span class="s">(line "</span> <span class="o">&lt;&lt;</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="s">") "</span>
	 <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="o">*</span><span class="n">q</span><span class="p">.</span><span class="n">sp1</span><span class="p">)[</span><span class="n">l</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">o</span><span class="p">;</span>
  <span class="p">}</span>
<span class="n">QueryResult</span> <span class="n">TextQuery</span><span class="o">::</span><span class="n">query</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
  <span class="k">static</span> <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">set</span><span class="o">&lt;</span><span class="n">line_no</span><span class="o">&gt;&gt;</span> <span class="n">nodata</span><span class="p">(</span><span class="k">new</span> <span class="n">set</span><span class="o">&lt;</span><span class="n">line_no</span><span class="o">&gt;</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">mp</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">last</span> <span class="o">=</span> <span class="n">mp</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
  <span class="k">if</span><span class="p">(</span><span class="n">iter</span> <span class="o">!=</span> <span class="n">last</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">QueryResult</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">,</span> <span class="n">sp1</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="nf">QueryResult</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">nodata</span><span class="p">,</span> <span class="n">sp1</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>
</pre></div>
</div>
</div>

<div id="outline-container-org850a7bd" class="outline-2">
<h2 id="org850a7bd">Exercise 13.22</h2>
<div class="outline-text-2" id="text-org850a7bd">
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">HasPtr</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">HasPtr</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span> <span class="o">=</span> <span class="n">string</span><span class="p">())</span><span class="o">:</span>
    <span class="n">ps</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="n">s</span><span class="p">)),</span> <span class="n">i</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
  <span class="n">HasPtr</span><span class="p">(</span><span class="k">const</span> <span class="n">HasPtr</span> <span class="o">&amp;</span><span class="n">h</span><span class="p">)</span><span class="o">:</span> <span class="n">ps</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="o">*</span><span class="n">h</span><span class="p">.</span><span class="n">ps</span><span class="p">)),</span> <span class="n">i</span><span class="p">(</span><span class="n">h</span><span class="p">.</span><span class="n">i</span><span class="p">)</span> <span class="p">{}</span>
  <span class="n">HasPtr</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">HasPtr</span> <span class="o">&amp;</span><span class="p">);</span>
  <span class="o">~</span><span class="n">HasPtr</span><span class="p">()</span> <span class="p">{</span><span class="k">delete</span> <span class="n">ps</span><span class="p">;};</span>
<span class="k">private</span><span class="o">:</span>
  <span class="n">string</span> <span class="o">*</span><span class="n">ps</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">HasPtr</span><span class="o">&amp;</span> <span class="n">HasPtr</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">HasPtr</span> <span class="o">&amp;</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">auto</span> <span class="n">newptr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="o">*</span><span class="n">h</span><span class="p">.</span><span class="n">ps</span><span class="p">);</span>
  <span class="k">delete</span> <span class="n">ps</span><span class="p">;</span>
  <span class="n">ps</span> <span class="o">=</span> <span class="n">newptr</span><span class="p">;</span>
  <span class="n">i</span> <span class="o">=</span> <span class="n">h</span><span class="p">.</span><span class="n">i</span><span class="p">;</span>
  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>

<div id="outline-container-orgdd5468f" class="outline-2">
<h2 id="orgdd5468f">Exercise 13.23</h2>
<div class="outline-text-2" id="text-orgdd5468f">
<div class="highlight"><pre><span></span><span class="c1">// See exercise 13.22.cpp, I made a lot of mistakes before.</span>
</pre></div>
</div>
</div>

<div id="outline-container-org9df142f" class="outline-2">
<h2 id="org9df142f">13.22.cpp</h2>
<div class="outline-text-2" id="text-org9df142f">
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">HasPtr</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">HasPtr</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span> <span class="o">=</span> <span class="n">string</span><span class="p">())</span><span class="o">:</span>
    <span class="n">ps</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="n">s</span><span class="p">)),</span> <span class="n">i</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
  <span class="n">HasPtr</span><span class="p">(</span><span class="k">const</span> <span class="n">HasPtr</span> <span class="o">&amp;</span><span class="n">h</span><span class="p">)</span><span class="o">:</span> <span class="n">ps</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="o">*</span><span class="n">h</span><span class="p">.</span><span class="n">ps</span><span class="p">)),</span> <span class="n">i</span><span class="p">(</span><span class="n">h</span><span class="p">.</span><span class="n">i</span><span class="p">)</span> <span class="p">{}</span>
  <span class="n">HasPtr</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">HasPtr</span> <span class="o">&amp;</span><span class="p">);</span>
  <span class="o">~</span><span class="n">HasPtr</span><span class="p">()</span> <span class="p">{</span><span class="k">delete</span> <span class="n">ps</span><span class="p">;};</span>
<span class="k">private</span><span class="o">:</span>
  <span class="n">string</span> <span class="o">*</span><span class="n">ps</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">HasPtr</span><span class="o">&amp;</span> <span class="n">HasPtr</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">HasPtr</span> <span class="o">&amp;</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">auto</span> <span class="n">newptr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="o">*</span><span class="n">h</span><span class="p">.</span><span class="n">ps</span><span class="p">);</span>
  <span class="k">delete</span> <span class="n">ps</span><span class="p">;</span>
  <span class="n">ps</span> <span class="o">=</span> <span class="n">newptr</span><span class="p">;</span>
  <span class="n">i</span> <span class="o">=</span> <span class="n">h</span><span class="p">.</span><span class="n">i</span><span class="p">;</span>
  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>

<div id="outline-container-org4323b8c" class="outline-2">
<h2 id="org4323b8c">Exercise 13.24</h2>
<div class="outline-text-2" id="text-org4323b8c">
<div class="highlight"><pre><span></span><span class="c1">// if not define a destructor in HasPtr class type, the dynamic memory space pointed by member ps would not be released after destruction of HasPtr object, then causes memory leak.</span>
<span class="c1">// if not define a copy constructor illustrated in section 12.2.1, copy initialization of HasPtr object would directly copy the value of member ps, thus at last two objects' ps member both point to the same dynamic memory space.</span>
</pre></div>
</div>
</div>

<div id="outline-container-org6a873ad" class="outline-2">
<h2 id="org6a873ad">Exercise 13.25</h2>
<div class="outline-text-2" id="text-org6a873ad">
<div class="highlight"><pre><span></span><span class="c1">// See StrBlob.h</span>
<span class="c1">// copy onstructor must allocate a new dynamic memory space for the content copied from the place pointed by original StrBlob object's shared_ptr, use the new shared_ptr object to initialize self's data member.</span>
<span class="c1">// copy assignment operator behaves almost like copy constructor, but it does not initialize data member, instead it assigns the new shared_ptr value to it.</span>
<span class="c1">// what's more, operator does not need to explicitly free the dynamic memory originally pointed by the old value of data member, for data's type is shared_ptr, the dynamic space arranged by shared_ptr would be automatically released when its reference count decreases to zero.</span>
<span class="c1">// StrBlob could rely its own synthesized destructor, for there is only one data member, and class type of member itself owns destrucor.</span>
</pre></div>
</div>
</div>

<div id="outline-container-orgb2c00e2" class="outline-2">
<h2 id="orgb2c00e2">StrBlob.h</h2>
<div class="outline-text-2" id="text-orgb2c00e2">
<div class="highlight"><pre><span></span><span class="cp">#ifndef STRBLOB_H</span>
<span class="cp">#define STRBLOB_H</span>
<span class="k">class</span> <span class="nc">StrBlobPtr</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">StrBlob</span>
<span class="p">{</span>
  <span class="k">friend</span> <span class="k">class</span> <span class="nc">StrBlobPtr</span><span class="p">;</span>
  <span class="k">friend</span> <span class="k">class</span> <span class="nc">ConstStrBlobPtr</span><span class="p">;</span>
  <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">StrBlob</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">StrBlob</span> <span class="o">&amp;</span><span class="p">);</span>
  <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">StrBlob</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">StrBlob</span> <span class="o">&amp;</span><span class="p">);</span>
  <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">StrBlob</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">StrBlob</span> <span class="o">&amp;</span><span class="p">);</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="k">typedef</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;::</span><span class="n">size_type</span> <span class="n">size_type</span><span class="p">;</span>
  <span class="n">StrBlob</span><span class="p">();</span>
  <span class="n">StrBlob</span><span class="p">(</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">il</span><span class="p">);</span>
  <span class="n">StrBlob</span><span class="p">(</span><span class="k">const</span> <span class="n">StrBlob</span> <span class="o">&amp;</span><span class="p">);</span>
  <span class="n">StrBlob</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">StrBlob</span> <span class="o">&amp;</span><span class="p">);</span>
  <span class="n">string</span> <span class="o">&amp;</span><span class="k">operator</span><span class="p">[](</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">);</span>
  <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="k">operator</span><span class="p">[](</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">size_type</span> <span class="nf">size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">();}</span>
  <span class="kt">bool</span> <span class="nf">empty</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">empty</span><span class="p">();}</span>
  <span class="kt">void</span> <span class="nf">push_back</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="n">t</span><span class="p">);}</span>
  <span class="kt">void</span> <span class="nf">push_back</span><span class="p">(</span><span class="n">string</span> <span class="o">&amp;&amp;</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">t</span><span class="p">));}</span>
  <span class="kt">void</span> <span class="nf">pop_back</span><span class="p">();</span>
  <span class="n">string</span> <span class="o">&amp;</span><span class="n">front</span><span class="p">();</span>
  <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">front</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">string</span> <span class="o">&amp;</span><span class="n">back</span><span class="p">();</span>
  <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">back</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">StrBlobPtr</span> <span class="nf">begin</span><span class="p">();</span>
    <span class="n">StrBlobPtr</span> <span class="nf">end</span><span class="p">();</span>
 <span class="k">private</span><span class="o">:</span>
  <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">data</span><span class="p">;</span>
  <span class="kt">void</span> <span class="nf">check</span><span class="p">(</span><span class="n">size_type</span> <span class="n">i</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">StrBlobPtr</span>
<span class="p">{</span>
  <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">StrBlobPtr</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">StrBlobPtr</span> <span class="o">&amp;</span><span class="p">);</span>
  <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">StrBlobPtr</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">StrBlobPtr</span> <span class="o">&amp;</span><span class="p">);</span>
  <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">StrBlobPtr</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">StrBlobPtr</span> <span class="o">&amp;</span><span class="p">);</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="n">string</span> <span class="o">&amp;</span><span class="k">operator</span><span class="p">[](</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">);</span>
  <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="k">operator</span><span class="p">[](</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
 <span class="n">StrBlobPtr</span><span class="p">()</span><span class="o">:</span> <span class="n">curr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
 <span class="n">StrBlobPtr</span><span class="p">(</span><span class="n">StrBlob</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">sz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span><span class="o">:</span>
  <span class="n">wptr</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">data</span><span class="p">),</span> <span class="n">curr</span><span class="p">(</span><span class="n">sz</span><span class="p">)</span> <span class="p">{}</span>
  <span class="n">string</span> <span class="o">&amp;</span><span class="n">deref</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">StrBlobPtr</span> <span class="o">&amp;</span><span class="n">incr</span><span class="p">();</span>
 <span class="k">private</span><span class="o">:</span>
  <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">check</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">wptr</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">curr</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">ConstStrBlobPtr</span>
<span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
 <span class="n">ConstStrBlobPtr</span><span class="p">()</span><span class="o">:</span> <span class="n">curr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
 <span class="n">ConstStrBlobPtr</span><span class="p">(</span><span class="k">const</span> <span class="n">StrBlob</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">sz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span><span class="o">:</span>
  <span class="n">wptr</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">data</span><span class="p">),</span> <span class="n">curr</span><span class="p">(</span><span class="n">sz</span><span class="p">)</span> <span class="p">{}</span>
  <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">deref</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">ConstStrBlobPtr</span> <span class="o">&amp;</span><span class="n">incr</span><span class="p">();</span>
 <span class="k">private</span><span class="o">:</span>
  <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">check</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">wptr</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">curr</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#endif</span>
</pre></div>
</div>
</div>

<div id="outline-container-org83c1cc9" class="outline-2">
<h2 id="org83c1cc9">Exercise 13.26</h2>
<div class="outline-text-2" id="text-org83c1cc9">
<div class="highlight"><pre><span></span><span class="c1">// See StrBlob.h</span>
</pre></div>

<p>
<a href="#orgb2c00e2">StrBlob.h</a>
</p>
</div>
</div>

<div id="outline-container-orga0d7e41" class="outline-2">
<h2 id="orga0d7e41">Exercise 13.27</h2>
<div class="outline-text-2" id="text-orga0d7e41">
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">HasPtr</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">HasPtr</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span> <span class="o">=</span> <span class="n">string</span><span class="p">())</span><span class="o">:</span>
    <span class="n">ps</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="n">s</span><span class="p">)),</span> <span class="n">use</span><span class="p">(</span><span class="k">new</span> <span class="kt">size_t</span><span class="p">(</span><span class="mi">1</span><span class="p">)),</span> <span class="n">i</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
  <span class="n">HasPtr</span><span class="p">(</span><span class="k">const</span> <span class="n">HasPtr</span> <span class="o">&amp;</span><span class="n">h</span><span class="p">)</span><span class="o">:</span> <span class="n">ps</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="o">*</span><span class="n">h</span><span class="p">.</span><span class="n">ps</span><span class="p">)),</span> <span class="n">use</span><span class="p">(</span><span class="n">h</span><span class="p">.</span><span class="n">use</span><span class="p">),</span><span class="n">i</span><span class="p">(</span><span class="n">h</span><span class="p">.</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span><span class="o">++*</span><span class="n">use</span><span class="p">;}</span>
  <span class="n">HasPtr</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">HasPtr</span> <span class="o">&amp;</span><span class="p">);</span>
  <span class="o">~</span><span class="n">HasPtr</span><span class="p">();</span>
<span class="k">private</span><span class="o">:</span>
  <span class="n">string</span> <span class="o">*</span><span class="n">ps</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="o">*</span><span class="n">use</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">HasPtr</span><span class="o">::~</span><span class="n">HasPtr</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="o">--*</span><span class="n">use</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">delete</span> <span class="n">ps</span><span class="p">;</span>
      <span class="k">delete</span> <span class="n">use</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">HasPtr</span><span class="o">&amp;</span> <span class="n">HasPtr</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">HasPtr</span> <span class="o">&amp;</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
  <span class="o">++*</span><span class="n">h</span><span class="p">.</span><span class="n">use</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span><span class="o">--*</span><span class="n">use</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">delete</span> <span class="n">ps</span><span class="p">;</span>
      <span class="k">delete</span> <span class="n">use</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="n">ps</span> <span class="o">=</span> <span class="n">h</span><span class="p">.</span><span class="n">ps</span><span class="p">;</span>
  <span class="n">i</span> <span class="o">=</span> <span class="n">h</span><span class="p">.</span><span class="n">i</span><span class="p">;</span>
  <span class="n">use</span> <span class="o">=</span> <span class="n">h</span><span class="p">.</span><span class="n">use</span><span class="p">;</span>
  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>

<div id="outline-container-org14de4e9" class="outline-2">
<h2 id="org14de4e9">Exercise 13.28</h2>
<div class="outline-text-2" id="text-org14de4e9">
<div class="highlight"><pre><span></span><span class="c1">// recursive widely used here.</span>
<span class="k">class</span> <span class="nc">BinStrTree</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">TreeNode</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
  <span class="n">string</span> <span class="n">value</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
  <span class="n">TreeNode</span> <span class="o">*</span><span class="n">left</span><span class="p">;</span>
  <span class="n">TreeNode</span> <span class="o">*</span><span class="n">right</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">TreeNode</span><span class="p">()</span><span class="o">:</span> <span class="n">count</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">left</span><span class="p">(</span><span class="k">nullptr</span><span class="p">),</span> <span class="n">right</span><span class="p">(</span><span class="k">nullptr</span><span class="p">)</span> <span class="p">{}</span>
  <span class="n">TreeNode</span><span class="p">(</span><span class="k">const</span> <span class="n">TreeNode</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">);</span>
  <span class="n">TreeNode</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">TreeNode</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">);</span>
  <span class="o">~</span><span class="n">TreeNode</span><span class="p">();</span>
<span class="p">};</span>
<span class="n">TreeNode</span><span class="o">::</span><span class="n">TreeNode</span><span class="p">(</span><span class="k">const</span> <span class="n">TreeNode</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">)</span><span class="o">:</span> <span class="n">value</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">value</span><span class="p">),</span> <span class="n">count</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">left</span><span class="p">)</span>
    <span class="n">left</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">.</span><span class="n">left</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
    <span class="n">right</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">.</span><span class="n">right</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">TreeNode</span> <span class="o">&amp;</span><span class="n">TreeNode</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">TreeNode</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">auto</span> <span class="n">new_left</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">.</span><span class="n">left</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">new_right</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">.</span><span class="n">right</span><span class="p">);</span>
  <span class="k">delete</span> <span class="n">left</span><span class="p">;</span>
  <span class="k">delete</span> <span class="n">right</span><span class="p">;</span>
  <span class="n">left</span> <span class="o">=</span> <span class="n">new_left</span><span class="p">;</span>
  <span class="n">right</span> <span class="o">=</span> <span class="n">new_right</span><span class="p">;</span>
  <span class="n">value</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>
  <span class="n">count</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="n">count</span><span class="p">;</span>
  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">TreeNode</span><span class="o">::~</span><span class="n">TreeNode</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">delete</span> <span class="n">left</span><span class="p">;</span>
  <span class="k">delete</span> <span class="n">right</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">class</span> <span class="nc">BinStrTree</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
  <span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">BinStrTree</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="n">BinStrTree</span><span class="p">(</span><span class="k">const</span> <span class="n">BinStrTree</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span><span class="o">:</span> <span class="n">root</span><span class="p">(</span><span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="o">*</span><span class="n">b</span><span class="p">.</span><span class="n">root</span><span class="p">))</span> <span class="p">{}</span>
  <span class="n">BinStrTree</span><span class="p">(</span><span class="k">const</span> <span class="n">TreeNode</span> <span class="o">&amp;</span><span class="n">t</span><span class="p">)</span><span class="o">:</span> <span class="n">root</span><span class="p">(</span><span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">t</span><span class="p">))</span> <span class="p">{}</span>
  <span class="n">BinStrTree</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">BinStrTree</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
  <span class="o">~</span><span class="n">BinStrTree</span><span class="p">();</span>
<span class="p">};</span>
<span class="n">BinStrTree</span> <span class="o">&amp;</span><span class="n">BinStrTree</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">BinStrTree</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">auto</span> <span class="n">new_root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="o">*</span><span class="n">b</span><span class="p">.</span><span class="n">root</span><span class="p">);</span>
  <span class="k">delete</span> <span class="n">root</span><span class="p">;</span>
  <span class="n">root</span> <span class="o">=</span> <span class="n">new_root</span><span class="p">;</span>
  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">BinStrTree</span><span class="o">::~</span><span class="n">BinStrTree</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">delete</span> <span class="n">root</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>

<div id="outline-container-org78e38ec" class="outline-2">
<h2 id="org78e38ec">Exercise 13.29</h2>
<div class="outline-text-2" id="text-org78e38ec">
<div class="highlight"><pre><span></span><span class="c1">// Because the swap version called in 'HasPtr &amp;HasPtr::operator=(HasPtr rhs)' is the type specified version, not std::swap.</span>
</pre></div>
</div>
</div>

<div id="outline-container-org014af56" class="outline-2">
<h2 id="org014af56">Exercise 13.30</h2>
<div class="outline-text-2" id="text-org014af56">
<div class="highlight"><pre><span></span><span class="c1">// See HasPtr.h.</span>
</pre></div>
</div>
</div>

<div id="outline-container-orgb1500a3" class="outline-2">
<h2 id="orgb1500a3">HasPtr.h</h2>
<div class="outline-text-2" id="text-orgb1500a3">
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">HasPtr</span>
<span class="p">{</span>
  <span class="k">friend</span> <span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">HasPtr</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">HasPtr</span> <span class="o">&amp;</span><span class="p">);</span>
 <span class="k">public</span><span class="o">:</span>
 <span class="n">HasPtr</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span> <span class="o">=</span> <span class="n">string</span><span class="p">())</span><span class="o">:</span> <span class="n">ps</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="n">s</span><span class="p">)),</span> <span class="n">i</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
  <span class="n">HasPtr</span><span class="p">(</span><span class="n">HasPtr</span> <span class="o">&amp;&amp;</span><span class="n">h</span><span class="p">)</span> <span class="k">noexcept</span><span class="o">:</span> <span class="n">ps</span><span class="p">(</span><span class="n">h</span><span class="p">.</span><span class="n">ps</span><span class="p">),</span> <span class="n">i</span><span class="p">(</span><span class="n">h</span><span class="p">.</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span><span class="n">h</span><span class="p">.</span><span class="n">ps</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;}</span>
 <span class="n">HasPtr</span><span class="p">(</span><span class="k">const</span> <span class="n">HasPtr</span> <span class="o">&amp;</span><span class="n">h</span><span class="p">)</span><span class="o">:</span> <span class="n">ps</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="o">*</span><span class="n">h</span><span class="p">.</span><span class="n">ps</span><span class="p">)),</span> <span class="n">i</span><span class="p">(</span><span class="n">h</span><span class="p">.</span><span class="n">i</span><span class="p">)</span> <span class="p">{}</span>
  <span class="n">HasPtr</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">HasPtr</span> <span class="o">&amp;</span><span class="p">);</span>
  <span class="n">HasPtr</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">HasPtr</span> <span class="o">&amp;&amp;</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
  <span class="o">~</span><span class="n">HasPtr</span><span class="p">()</span> <span class="p">{</span><span class="k">delete</span> <span class="n">ps</span><span class="p">;};</span>
 <span class="k">private</span><span class="o">:</span>
  <span class="n">string</span> <span class="o">*</span><span class="n">ps</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">HasPtr</span><span class="o">&amp;</span> <span class="n">HasPtr</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">HasPtr</span> <span class="o">&amp;&amp;</span><span class="n">h</span><span class="p">)</span> <span class="k">noexcept</span>
<span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="k">this</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">h</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">delete</span> <span class="n">ps</span><span class="p">;</span>
      <span class="n">ps</span> <span class="o">=</span> <span class="n">h</span><span class="p">.</span><span class="n">ps</span><span class="p">;</span>
      <span class="n">i</span> <span class="o">=</span> <span class="n">h</span><span class="p">.</span><span class="n">i</span><span class="p">;</span>
      <span class="n">h</span><span class="p">.</span><span class="n">ps</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">string</span> <span class="o">*</span><span class="n">p1</span><span class="p">,</span> <span class="n">string</span> <span class="o">*</span><span class="n">p2</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">string</span> <span class="o">*</span><span class="n">temp</span> <span class="o">=</span> <span class="n">p1</span><span class="p">;</span>
  <span class="n">p1</span> <span class="o">=</span> <span class="n">p2</span><span class="p">;</span>
  <span class="n">p2</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">HasPtr</span> <span class="o">&amp;</span><span class="n">h1</span><span class="p">,</span> <span class="n">HasPtr</span> <span class="o">&amp;</span><span class="n">h2</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"swap(HasPtr &amp;h1, HasPtr &amp;h2)"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="n">swap</span><span class="p">(</span><span class="n">h1</span><span class="p">.</span><span class="n">ps</span><span class="p">,</span> <span class="n">h2</span><span class="p">.</span><span class="n">ps</span><span class="p">);</span>
  <span class="n">swap</span><span class="p">(</span><span class="n">h1</span><span class="p">.</span><span class="n">i</span><span class="p">,</span> <span class="n">h2</span><span class="p">.</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">HasPtr</span><span class="o">&amp;</span> <span class="n">HasPtr</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">HasPtr</span><span class="o">&amp;</span> <span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// swap(*this, h);</span>
  <span class="n">ps</span> <span class="o">=</span> <span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="o">*</span><span class="n">h</span><span class="p">.</span><span class="n">ps</span><span class="p">);</span>
  <span class="n">i</span> <span class="o">=</span> <span class="n">h</span><span class="p">.</span><span class="n">i</span><span class="p">;</span>
  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>

<div id="outline-container-orga6bebfb" class="outline-2">
<h2 id="orga6bebfb">Exercise 13.31</h2>
<div class="outline-text-2" id="text-orga6bebfb">
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">HasPtr</span>
<span class="p">{</span>
  <span class="k">friend</span> <span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">HasPtr</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">HasPtr</span> <span class="o">&amp;</span><span class="p">);</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">HasPtr</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span> <span class="o">=</span> <span class="n">string</span><span class="p">())</span><span class="o">:</span>
    <span class="n">ps</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="n">s</span><span class="p">)),</span> <span class="n">i</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
  <span class="n">HasPtr</span><span class="p">(</span><span class="k">const</span> <span class="n">HasPtr</span> <span class="o">&amp;</span><span class="n">h</span><span class="p">)</span><span class="o">:</span> <span class="n">ps</span><span class="p">(</span><span class="k">new</span> <span class="n">string</span><span class="p">(</span><span class="o">*</span><span class="n">h</span><span class="p">.</span><span class="n">ps</span><span class="p">)),</span> <span class="n">i</span><span class="p">(</span><span class="n">h</span><span class="p">.</span><span class="n">i</span><span class="p">)</span> <span class="p">{}</span>
  <span class="n">HasPtr</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">HasPtr</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="n">HasPtr</span> <span class="o">&amp;</span><span class="p">);</span>
  <span class="o">~</span><span class="n">HasPtr</span><span class="p">()</span> <span class="p">{</span><span class="k">delete</span> <span class="n">ps</span><span class="p">;};</span>
<span class="k">private</span><span class="o">:</span>
  <span class="n">string</span> <span class="o">*</span><span class="n">ps</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="p">};</span>
<span class="kt">bool</span> <span class="n">HasPtr</span><span class="o">::</span><span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="n">HasPtr</span> <span class="o">&amp;</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="o">*</span><span class="n">ps</span> <span class="o">&lt;</span> <span class="o">*</span><span class="p">(</span><span class="n">h</span><span class="p">.</span><span class="n">ps</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">string</span> <span class="o">*</span><span class="n">p1</span><span class="p">,</span> <span class="n">string</span> <span class="o">*</span><span class="n">p2</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">string</span> <span class="o">*</span><span class="n">temp</span> <span class="o">=</span> <span class="n">p1</span><span class="p">;</span>
  <span class="n">p1</span> <span class="o">=</span> <span class="n">p2</span><span class="p">;</span>
  <span class="n">p2</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">HasPtr</span> <span class="o">&amp;</span><span class="n">h1</span><span class="p">,</span> <span class="n">HasPtr</span> <span class="o">&amp;</span><span class="n">h2</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"swap(HasPtr &amp;h1, HasPtr &amp;h2)"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="n">swap</span><span class="p">(</span><span class="n">h1</span><span class="p">.</span><span class="n">ps</span><span class="p">,</span> <span class="n">h2</span><span class="p">.</span><span class="n">ps</span><span class="p">);</span>
  <span class="n">swap</span><span class="p">(</span><span class="n">h1</span><span class="p">.</span><span class="n">i</span><span class="p">,</span> <span class="n">h2</span><span class="p">.</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">HasPtr</span><span class="o">&amp;</span> <span class="n">HasPtr</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">HasPtr</span> <span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">HasPtr</span><span class="o">&gt;</span> <span class="n">vh</span><span class="p">;</span>
  <span class="n">vh</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">HasPtr</span><span class="p">(</span><span class="s">"hello"</span><span class="p">));</span>
  <span class="n">vh</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">HasPtr</span><span class="p">(</span><span class="s">"you"</span><span class="p">));</span>
  <span class="n">vh</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">HasPtr</span><span class="p">(</span><span class="s">"me"</span><span class="p">));</span>
  <span class="n">sort</span><span class="p">(</span><span class="n">vh</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vh</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
</div>

<div id="outline-container-org15afae3" class="outline-2">
<h2 id="org15afae3">Exercise 13.32</h2>
<div class="outline-text-2" id="text-org15afae3">
<div class="highlight"><pre><span></span><span class="c1">// Gets fewer benefits than the value-like class;</span>
<span class="c1">// only saves the work of copy initialization of the HasPtr temp object, and the increase &amp; decrease of reference counts.</span>
</pre></div>
</div>
</div>

<div id="outline-container-orga1cb715" class="outline-2">
<h2 id="orga1cb715">Exercise 13.33</h2>
<div class="outline-text-2" id="text-orga1cb715">
<div class="highlight"><pre><span></span><span class="c1">// Both functions aim to modify the exact Folder object passed in.</span>
<span class="c1">// if the type of parameter of save and remove is 'Folder': that would use the argument to copy initialize the paremeter, both functions aim to modify the Folder object passed in, not the copy of it.</span>
<span class="c1">// if it is 'const Folder &amp;', it is impossibile to modify a const Folder object, the expressions within function body are illegal.</span>
</pre></div>
</div>
</div>

<div id="outline-container-orgac3a7b0" class="outline-2">
<h2 id="orgac3a7b0">Exercise 13.34</h2>
<div class="outline-text-2" id="text-orgac3a7b0">
<div class="highlight"><pre><span></span><span class="c1">// See Message.h.</span>
</pre></div>
</div>
</div>

<div id="outline-container-org4934fbd" class="outline-2">
<h2 id="org4934fbd">Message.h</h2>
<div class="outline-text-2" id="text-org4934fbd">
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Message</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">Folder</span>
<span class="p">{</span>
  <span class="n">set</span><span class="o">&lt;</span><span class="n">Message</span><span class="o">*&gt;</span> <span class="n">messages</span><span class="p">;</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="n">Folder</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="n">Folder</span><span class="p">(</span><span class="k">const</span> <span class="n">Folder</span> <span class="o">&amp;</span><span class="p">);</span>
  <span class="o">~</span><span class="n">Folder</span><span class="p">();</span>
  <span class="kt">void</span> <span class="nf">addMsg</span><span class="p">(</span><span class="n">Message</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span><span class="n">messages</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">m</span><span class="p">);}</span>
  <span class="kt">void</span> <span class="nf">remMsg</span><span class="p">(</span><span class="n">Message</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span><span class="n">messages</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">m</span><span class="p">);}</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">Message</span>
<span class="p">{</span>
  <span class="k">friend</span> <span class="k">class</span> <span class="nc">Folder</span><span class="p">;</span>
  <span class="k">friend</span> <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">Message</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">Message</span> <span class="o">&amp;</span><span class="p">);</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="k">explicit</span> <span class="n">Message</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">str</span> <span class="o">=</span> <span class="s">""</span><span class="p">)</span><span class="o">:</span> <span class="n">contents</span><span class="p">(</span><span class="n">str</span><span class="p">)</span> <span class="p">{}</span>
  <span class="n">Message</span><span class="p">(</span><span class="k">const</span> <span class="n">Message</span> <span class="o">&amp;</span><span class="p">);</span>
  <span class="n">Message</span><span class="p">(</span><span class="n">Message</span> <span class="o">&amp;&amp;</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
  <span class="n">Message</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Message</span> <span class="o">&amp;</span><span class="p">);</span>
  <span class="n">Message</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Message</span> <span class="o">&amp;&amp;</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
  <span class="o">~</span><span class="n">Message</span><span class="p">();</span>
  <span class="kt">void</span> <span class="nf">save</span><span class="p">(</span><span class="n">Folder</span> <span class="o">&amp;</span><span class="p">);</span>
  <span class="kt">void</span> <span class="nf">remove</span><span class="p">(</span><span class="n">Folder</span> <span class="o">&amp;</span><span class="p">);</span>
  <span class="kt">void</span> <span class="nf">addFod</span><span class="p">(</span><span class="n">Folder</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span> <span class="p">{</span><span class="n">folders</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">f</span><span class="p">);}</span>
  <span class="kt">void</span> <span class="nf">remFod</span><span class="p">(</span><span class="n">Folder</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span> <span class="p">{</span><span class="n">folders</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">f</span><span class="p">);}</span>
 <span class="k">private</span><span class="o">:</span>
  <span class="n">string</span> <span class="n">contents</span><span class="p">;</span>
  <span class="n">set</span><span class="o">&lt;</span><span class="n">Folder</span><span class="o">*&gt;</span> <span class="n">folders</span><span class="p">;</span>
  <span class="kt">void</span> <span class="nf">add_to_Folders</span><span class="p">(</span><span class="k">const</span> <span class="n">Message</span> <span class="o">&amp;</span><span class="p">);</span>
  <span class="kt">void</span> <span class="nf">remove_from_Folders</span><span class="p">();</span>
  <span class="kt">void</span> <span class="nf">move_Folders</span><span class="p">(</span><span class="n">Message</span> <span class="o">*</span><span class="p">);</span>
<span class="p">};</span>
<span class="kt">void</span> <span class="n">Message</span><span class="o">::</span><span class="n">save</span><span class="p">(</span><span class="n">Folder</span> <span class="o">&amp;</span><span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">folders</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="p">);</span>
  <span class="n">f</span><span class="p">.</span><span class="n">addMsg</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">Message</span><span class="o">::</span><span class="n">remove</span><span class="p">(</span><span class="n">Folder</span> <span class="o">&amp;</span><span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">folders</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="p">);</span>
  <span class="n">f</span><span class="p">.</span><span class="n">remMsg</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">Message</span><span class="o">::</span><span class="n">add_to_Folders</span><span class="p">(</span><span class="k">const</span> <span class="n">Message</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">f</span> <span class="p">:</span> <span class="n">m</span><span class="p">.</span><span class="n">folders</span><span class="p">)</span>
    <span class="n">f</span><span class="o">-&gt;</span><span class="n">addMsg</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">Message</span><span class="o">::</span><span class="n">Message</span><span class="p">(</span><span class="k">const</span> <span class="n">Message</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">)</span><span class="o">:</span>
<span class="n">contents</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">contents</span><span class="p">),</span> <span class="n">folders</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">folders</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">add_to_Folders</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">Message</span><span class="o">::</span><span class="n">Message</span><span class="p">(</span><span class="n">Message</span> <span class="o">&amp;&amp;</span><span class="n">m</span><span class="p">)</span> <span class="k">noexcept</span><span class="o">:</span> <span class="n">contents</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">contents</span><span class="p">))</span>
<span class="p">{</span>
  <span class="n">move_Folders</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">Message</span><span class="o">::</span><span class="n">remove_from_Folders</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">f</span> <span class="p">:</span> <span class="n">folders</span><span class="p">)</span>
    <span class="n">f</span><span class="o">-&gt;</span><span class="n">remMsg</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">Message</span><span class="o">::~</span><span class="n">Message</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">remove_from_Folders</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">Message</span><span class="o">&amp;</span> <span class="n">Message</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Message</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">remove_from_Folders</span><span class="p">();</span>
  <span class="n">contents</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">contents</span><span class="p">;</span>
  <span class="n">folders</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">folders</span><span class="p">;</span>
  <span class="n">add_to_Folders</span><span class="p">(</span><span class="n">rhs</span><span class="p">);</span>
  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
  <span class="n">Message</span><span class="o">&amp;</span> <span class="n">Message</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Message</span> <span class="o">&amp;&amp;</span><span class="n">m</span><span class="p">)</span> <span class="k">noexcept</span>
  <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="k">this</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
      <span class="p">{</span>
      <span class="n">remove_from_Folders</span><span class="p">();</span>
      <span class="n">contents</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">contents</span><span class="p">);</span>
      <span class="n">move_Folders</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>
    <span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">Message</span> <span class="o">&amp;</span><span class="n">lhs</span><span class="p">,</span> <span class="n">Message</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">f</span> <span class="p">:</span> <span class="n">lhs</span><span class="p">.</span><span class="n">folders</span><span class="p">)</span>
      <span class="n">f</span><span class="o">-&gt;</span><span class="n">remMsg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lhs</span><span class="p">);</span>
      <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">f</span> <span class="p">:</span> <span class="n">rhs</span><span class="p">.</span><span class="n">folders</span><span class="p">)</span>
      <span class="n">f</span><span class="o">-&gt;</span><span class="n">remMsg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rhs</span><span class="p">);</span>
      <span class="n">swap</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">folders</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">folders</span><span class="p">);</span>
      <span class="n">swap</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">contents</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">contents</span><span class="p">);</span>
      <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">f</span> <span class="p">:</span> <span class="n">lhs</span><span class="p">.</span><span class="n">folders</span><span class="p">)</span>
      <span class="n">f</span><span class="o">-&gt;</span><span class="n">addMsg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lhs</span><span class="p">);</span>
      <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">f</span> <span class="p">:</span> <span class="n">rhs</span><span class="p">.</span><span class="n">folders</span><span class="p">)</span>
      <span class="n">f</span><span class="o">-&gt;</span><span class="n">addMsg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rhs</span><span class="p">);</span>
    <span class="p">}</span>
<span class="n">Folder</span><span class="o">::~</span><span class="n">Folder</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">m</span> <span class="p">:</span> <span class="n">messages</span><span class="p">)</span>
    <span class="n">m</span><span class="o">-&gt;</span><span class="n">remove</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">Folder</span><span class="o">::</span><span class="n">Folder</span><span class="p">(</span><span class="k">const</span> <span class="n">Folder</span> <span class="o">&amp;</span><span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">messages</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
  <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">m</span> <span class="p">:</span> <span class="n">messages</span><span class="p">)</span>
    <span class="n">m</span><span class="o">-&gt;</span><span class="n">remove</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
  <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">m</span> <span class="p">:</span> <span class="n">f</span><span class="p">.</span><span class="n">messages</span><span class="p">)</span>
    <span class="n">m</span><span class="o">-&gt;</span><span class="n">save</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="n">Message</span><span class="o">::</span><span class="n">move_Folders</span><span class="p">(</span><span class="n">Message</span> <span class="o">*</span><span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">folders</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">folders</span><span class="p">);</span>
  <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="nl">f</span> <span class="p">:</span> <span class="n">folders</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">f</span><span class="o">-&gt;</span><span class="n">remMsg</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
      <span class="n">f</span><span class="o">-&gt;</span><span class="n">addMsg</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="n">m</span><span class="o">-&gt;</span><span class="n">folders</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>

<div id="outline-container-orgb565da9" class="outline-2">
<h2 id="orgb565da9">Exercise 13.35</h2>
<div class="outline-text-2" id="text-orgb565da9">
<div class="highlight"><pre><span></span><span class="c1">// is using synthesized version of copy control members:</span>
<span class="c1">// for copy constructor: no folder contains the pointer which points to this newly constructed Message object;</span>
<span class="c1">// for destructor: even destructed, folders still contains the pointer which points to the invalid memory space which once stored this destructed object.</span>
<span class="c1">// for copy assignment constructor: this case is a combination of copy constructor and destructor illustrated above, the folders-message relationship stays the same but it should have been updated.</span>
</pre></div>
</div>
</div>

<div id="outline-container-orgb901225" class="outline-2">
<h2 id="orgb901225">Exercise 13.36</h2>
<div class="outline-text-2" id="text-orgb901225">
<div class="highlight"><pre><span></span><span class="c1">// See Message.h.</span>
</pre></div>

<p>
<a href="#org4934fbd">Message.h</a>
</p>
</div>
</div>

<div id="outline-container-orgb715036" class="outline-2">
<h2 id="orgb715036">Exercise 13.37</h2>
<div class="outline-text-2" id="text-orgb715036">
<div class="highlight"><pre><span></span><span class="c1">// see Message.h.</span>
</pre></div>

<p>
<a href="#org4934fbd">Message.h</a>
</p>
</div>
</div>

<div id="outline-container-org74314a3" class="outline-2">
<h2 id="org74314a3">Exercise 13.38</h2>
<div class="outline-text-2" id="text-org74314a3">
<div class="highlight"><pre><span></span><span class="c1">// void swap(message &amp;lhs, Message &amp;rhs)</span>
<span class="c1">// its implementation really swaps the contents of the two passed in arguments,</span>
<span class="c1">// and Message &amp;Message::operator=(const Message &amp;rhs) has a const reference type parameter, if this copy assignment operator calls swap(message &amp;lhs,, Messag &amp;rhs),</span>
<span class="c1">// the operations within swap is illegal;</span>
<span class="c1">// even though there is a way of copy initializing a non-const temp object from rhs, and pass it to swap as second argument, which would make it reasonable;</span>
<span class="c1">// but there is a lot of unnecessary work defined in swap for copy assignment operator; for example, destruction and rebuild of the message-folders relationship of the second parameter is a waste of time and space.</span>
</pre></div>
</div>
</div>

<div id="outline-container-orgde31c74" class="outline-2">
<h2 id="orgde31c74">Exercise 13.39</h2>
<div class="outline-text-2" id="text-orgde31c74">
<div class="highlight"><pre><span></span><span class="c1">// see StrVec.h.</span>
</pre></div>
</div>
</div>

<div id="outline-container-org9c00134" class="outline-2">
<h2 id="org9c00134">StrVec.h</h2>
<div class="outline-text-2" id="text-org9c00134">
<div class="highlight"><pre><span></span><span class="cp">#ifndef STRVEC_H</span>
<span class="cp">#define STRVEC_H</span>
<span class="k">class</span> <span class="nc">StrVec</span>
<span class="p">{</span>
  <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">StrVec</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">StrVec</span> <span class="o">&amp;</span><span class="p">);</span>
  <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">StrVec</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">StrVec</span> <span class="o">&amp;</span><span class="p">);</span>
  <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">StrVec</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">StrVec</span> <span class="o">&amp;</span><span class="p">);</span>
 <span class="k">public</span><span class="o">:</span>
 <span class="n">StrVec</span><span class="p">()</span><span class="o">:</span> <span class="n">elements</span><span class="p">(</span><span class="k">nullptr</span><span class="p">),</span> <span class="n">first_free</span><span class="p">(</span><span class="k">nullptr</span><span class="p">),</span> <span class="n">cap</span><span class="p">(</span><span class="k">nullptr</span><span class="p">)</span> <span class="p">{}</span>
  <span class="n">StrVec</span><span class="p">(</span><span class="k">const</span> <span class="n">StrVec</span> <span class="o">&amp;</span><span class="p">);</span>
  <span class="n">StrVec</span><span class="p">(</span><span class="n">StrVec</span> <span class="o">&amp;&amp;</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
  <span class="n">StrVec</span><span class="p">(</span><span class="k">const</span> <span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">is</span><span class="p">);</span>
  <span class="n">StrVec</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">StrVec</span> <span class="o">&amp;</span><span class="p">);</span>
  <span class="n">StrVec</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">StrVec</span> <span class="o">&amp;&amp;</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
  <span class="n">StrVec</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="p">);</span>
  <span class="n">string</span> <span class="o">&amp;</span><span class="k">operator</span><span class="p">[](</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">);</span>
  <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="k">operator</span><span class="p">[](</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="o">~</span><span class="n">StrVec</span><span class="p">();</span>
  <span class="kt">void</span> <span class="nf">push_back</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="p">);</span>
  <span class="kt">size_t</span> <span class="nf">size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">first_free</span> <span class="o">-</span> <span class="n">elements</span><span class="p">;}</span>
  <span class="kt">size_t</span> <span class="nf">capacity</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">cap</span> <span class="o">-</span> <span class="n">elements</span><span class="p">;}</span>
  <span class="kt">void</span> <span class="nf">reserve</span><span class="p">(</span><span class="kt">size_t</span><span class="p">);</span>
  <span class="kt">void</span> <span class="nf">resize</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="s">""</span><span class="p">);</span>
  <span class="n">string</span> <span class="o">*</span><span class="nf">begin</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">elements</span><span class="p">;}</span>
  <span class="n">string</span> <span class="o">*</span><span class="nf">end</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">first_free</span><span class="p">;}</span>
 <span class="k">private</span><span class="o">:</span>
  <span class="n">allocator</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">alloc</span><span class="p">;</span> <span class="cm">/* it using static, 'undefined reference' reported when compile */</span>
  <span class="kt">void</span> <span class="nf">chk_n_alloc</span><span class="p">()</span>
  <span class="p">{</span><span class="k">if</span><span class="p">(</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">capacity</span><span class="p">())</span> <span class="n">reallocate</span><span class="p">();}</span>
  <span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span> <span class="o">*</span><span class="p">,</span> <span class="n">string</span> <span class="o">*&gt;</span> <span class="n">alloc_n_copy</span>
    <span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">*</span><span class="p">);</span>
  <span class="kt">void</span> <span class="nf">free</span><span class="p">();</span>
  <span class="kt">void</span> <span class="nf">reallocate</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">string</span> <span class="o">*</span><span class="n">elements</span><span class="p">;</span>
  <span class="n">string</span> <span class="o">*</span><span class="n">first_free</span><span class="p">;</span>
  <span class="n">string</span> <span class="o">*</span><span class="n">cap</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#endif</span>
</pre></div>
</div>
</div>

<div id="outline-container-orgd97b139" class="outline-2">
<h2 id="orgd97b139">Exercise 13.40</h2>
<div class="outline-text-2" id="text-orgd97b139">
<div class="highlight"><pre><span></span><span class="c1">// See StrVec.h</span>
</pre></div>

<p>
<a href="#org9c00134">StrVec.h</a>
</p>
</div>
</div>

<div id="outline-container-org1a13ff5" class="outline-2">
<h2 id="org1a13ff5">Exercise 13.41</h2>
<div class="outline-text-2" id="text-org1a13ff5">
<div class="highlight"><pre><span></span><span class="c1">// 'first_free++' keeps the original value of i as temp, increase first_free itself, and return the temp;</span>
<span class="c1">// if use '++first_free', increase first_free, and return it; that is not right, if use that version, it would not construct the specified string object at right place but the place next to it, which means, this operation would skip the right place.</span>
</pre></div>
</div>
</div>

<div id="outline-container-org1edbb9d" class="outline-2">
<h2 id="org1edbb9d">Exercise 13.42</h2>
<div class="outline-text-2" id="text-org1edbb9d">
<div class="highlight"><pre><span></span><span class="c1">// See TextQuery.h.</span>
<span class="kt">void</span> <span class="nf">runQueries</span><span class="p">(</span><span class="n">ifstream</span> <span class="o">&amp;</span><span class="n">infile</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">TextQuery</span> <span class="n">tq</span><span class="p">(</span><span class="n">infile</span><span class="p">);</span>
  <span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Enter word to look for, or q to quit: "</span><span class="p">;</span>
      <span class="n">string</span> <span class="n">s</span><span class="p">;</span>
      <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">s</span><span class="p">)</span> <span class="o">||</span> <span class="n">s</span> <span class="o">==</span> <span class="s">"q"</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
      <span class="n">print</span><span class="p">(</span><span class="n">cout</span><span class="p">,</span> <span class="n">tq</span><span class="p">.</span><span class="n">query</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="n">ifstream</span> <span class="n">ifs</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
  <span class="n">runQueries</span><span class="p">(</span><span class="n">ifs</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>

<p>
<a href="#orgac04472">TextQuery.h</a>
</p>
</div>
</div>

<div id="outline-container-org92ed7a7" class="outline-2">
<h2 id="org92ed7a7">Exercise 13.43</h2>
<div class="outline-text-2" id="text-org92ed7a7">
<div class="highlight"><pre><span></span><span class="c1">// see StrVec.h.</span>
<span class="c1">// the original one is better, use for loop, it could destroy elememts in a reverse order as required, that form is more flexible.</span>
<span class="c1">// thr for_each one could not destroy elements in a reverse order, for the string poniter could not behave like a reverse iterator, the form of this for_each syntax has its advantages of simple and easy to use, but has more restrictions than for type syntax.</span>
</pre></div>

<p>
<a href="#org9c00134">StrVec.h</a>
</p>
</div>
</div>

<div id="outline-container-orgf216043" class="outline-2">
<h2 id="orgf216043">Exercise 13.44</h2>
<div class="outline-text-2" id="text-orgf216043">
<div class="highlight"><pre><span></span><span class="c1">// See String.h.</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">String</span> <span class="n">s1</span><span class="p">;</span>
  <span class="n">String</span> <span class="n">s2</span><span class="p">(</span><span class="s">"Sing for me!"</span><span class="p">);</span>
  <span class="n">s1</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
  <span class="n">s2</span><span class="p">.</span><span class="n">print</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>

<div id="outline-container-org801deca" class="outline-2">
<h2 id="org801deca">String.h</h2>
<div class="outline-text-2" id="text-org801deca">
<div class="highlight"><pre><span></span><span class="cp">#ifndef STRING_H_EX</span>
<span class="cp">#define STRING_H_EX</span>
<span class="k">class</span> <span class="nc">String</span>
<span class="p">{</span>
  <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">String</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">String</span> <span class="o">&amp;</span><span class="p">);</span>
  <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">String</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">String</span> <span class="o">&amp;</span><span class="p">);</span>
  <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">String</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">String</span> <span class="o">&amp;</span><span class="p">);</span>
 <span class="k">public</span><span class="o">:</span>
 <span class="n">String</span><span class="p">()</span><span class="o">:</span> <span class="n">elements</span><span class="p">(</span><span class="k">nullptr</span><span class="p">),</span> <span class="n">first_free</span><span class="p">(</span><span class="k">nullptr</span><span class="p">),</span> <span class="n">cap</span><span class="p">(</span><span class="k">nullptr</span><span class="p">)</span> <span class="p">{}</span>
  <span class="n">String</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
  <span class="n">String</span><span class="p">(</span><span class="k">const</span> <span class="n">String</span> <span class="o">&amp;</span><span class="p">);</span>
  <span class="n">String</span><span class="p">(</span><span class="n">String</span> <span class="o">&amp;&amp;</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
  <span class="n">String</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">String</span> <span class="o">&amp;</span><span class="p">);</span>
  <span class="n">String</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">String</span> <span class="o">&amp;&amp;</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
  <span class="kt">char</span> <span class="o">&amp;</span><span class="k">operator</span><span class="p">[](</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">);</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">&amp;</span><span class="k">operator</span><span class="p">[](</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="o">~</span><span class="n">String</span><span class="p">();</span>
  <span class="kt">void</span> <span class="nf">push_back</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">&amp;</span><span class="p">);</span>
  <span class="kt">size_t</span> <span class="nf">size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">first_free</span> <span class="o">-</span> <span class="n">elements</span><span class="p">;}</span>
  <span class="kt">size_t</span> <span class="nf">capacity</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">cap</span> <span class="o">-</span> <span class="n">elements</span><span class="p">;}</span>
  <span class="kt">char</span> <span class="o">*</span><span class="nf">begin</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">elements</span><span class="p">;}</span>
  <span class="kt">char</span> <span class="o">*</span><span class="nf">end</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="n">first_free</span><span class="p">;}</span>
  <span class="n">ostream</span> <span class="o">&amp;</span><span class="n">print</span><span class="p">();</span>
 <span class="k">private</span><span class="o">:</span>
  <span class="n">allocator</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">alloc</span><span class="p">;</span> <span class="cm">/* it using static, 'undefined reference' reported when compile */</span>
  <span class="kt">void</span> <span class="nf">chk_n_alloc</span><span class="p">()</span>
  <span class="p">{</span><span class="k">if</span><span class="p">(</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">capacity</span><span class="p">())</span> <span class="n">reallocate</span><span class="p">();}</span>
  <span class="n">pair</span><span class="o">&lt;</span><span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*&gt;</span> <span class="n">alloc_n_copy</span>
    <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
  <span class="kt">void</span> <span class="nf">free</span><span class="p">();</span>
  <span class="kt">void</span> <span class="nf">reallocate</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">elements</span><span class="p">;</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">first_free</span><span class="p">;</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">cap</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#endif</span>
</pre></div>
</div>
</div>

<div id="outline-container-org59546f3" class="outline-2">
<h2 id="org59546f3">Exercise 13.45</h2>
<div class="outline-text-2" id="text-org59546f3">
<div class="highlight"><pre><span></span><span class="c1">// Difference between lvalue reference and rvalue reference:</span>
<span class="c1">// lvalue reference: could not bind to expressions which require convertion, literal constants or erpressions which return rvalue; could bind to expressions which returns lvalue.</span>
<span class="c1">// rvalue reference; just the opposite to the lvalue reference. </span>
</pre></div>
</div>
</div>

<div id="outline-container-org614f86f" class="outline-2">
<h2 id="org614f86f">Exercise 13.46</h2>
<div class="outline-text-2" id="text-org614f86f">
<div class="highlight"><pre><span></span><span class="c1">// int f(); </span>
<span class="c1">// vector&lt;int&gt; vi(100);</span>
<span class="c1">// int &amp;&amp;r1 = f();</span>
<span class="c1">// int &amp;r2 = vi[0];</span>
<span class="c1">// int &amp;r3 = r1;</span>
<span class="c1">// int &amp;&amp;r4 = vi[0] * f();</span>
</pre></div>
</div>
</div>

<div id="outline-container-org5dbd7f7" class="outline-2">
<h2 id="org5dbd7f7">Exercise 13.47</h2>
<div class="outline-text-2" id="text-org5dbd7f7">
<div class="highlight"><pre><span></span><span class="c1">// see String.h.</span>
</pre></div>

<p>
<a href="#org801deca">String.h</a>
</p>
</div>
</div>

<div id="outline-container-org2474f4f" class="outline-2">
<h2 id="org2474f4f">Exercise 13.48</h2>
<div class="outline-text-2" id="text-org2474f4f">
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">vs</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Initialize vector&lt;String&gt; object"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">String</span> <span class="n">s</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Initialize String object"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Push first"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">vs</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Push second"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="n">vs</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Push third"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="c1">// vs.push_back(String("word"));</span>
  <span class="n">vs</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// echo "String::String(const String &amp;s) six times</span>
<span class="c1">// for there is a memory reallocation processing during push_back.</span>
</pre></div>
</div>
</div>

<div id="outline-container-org53cc1b8" class="outline-2">
<h2 id="org53cc1b8">Exercise 13.49</h2>
<div class="outline-text-2" id="text-org53cc1b8">
<div class="highlight"><pre><span></span><span class="c1">// See StrVec.h, String.h, Message.h.</span>
</pre></div>

<p>
<a href="#org4934fbd">Message.h</a>
</p>

<p>
<a href="#org9c00134">StrVec.h</a>
</p>

<p>
<a href="#org801deca">String.h</a>
</p>
</div>
</div>

<div id="outline-container-orgb6d56f8" class="outline-2">
<h2 id="orgb6d56f8">Exercise 13.50</h2>
<div class="outline-text-2" id="text-orgb6d56f8">
<div class="highlight"><pre><span></span><span class="c1">// When the vector&lt;String&gt; object does not have enough space and then processes memory reallocation, it would use move constructor instead of copy constructor of String type during the reallocation of original elements.</span>
</pre></div>
</div>
</div>

<div id="outline-container-orge893c86" class="outline-2">
<h2 id="orge893c86">Exercise 13.51</h2>
<div class="outline-text-2" id="text-orge893c86">
<div class="highlight"><pre><span></span><span class="c1">// unique_ptr supports move constructor and move-assignment operator;</span>
<span class="c1">// the source objects are to be destroyed.</span>
</pre></div>
</div>
</div>

<div id="outline-container-org4f9236b" class="outline-2">
<h2 id="org4f9236b">Exercise 13.52</h2>
<div class="outline-text-2" id="text-org4f9236b">
<div class="highlight"><pre><span></span><span class="c1">// HasPtr hp = hp2;</span>
<span class="c1">// hp2 is lvaule, using copy constructor to initialize hp, hp2 stays unchanged, hp is the copy of hp2;</span>
<span class="c1">// HasPtr hp = std::move(hp2);</span>
<span class="c1">// std::move(hp2) returns a rvalue reference binded to lvalue hp2;</span>
<span class="c1">// so using move constructor to initialize hp, hp gets the control of the resouces owned by hp2;</span>
<span class="c1">// while hp2 is valid, in a destruction-safe state, but there is no gurantee of the hp2's contents.</span>
<span class="c1">// as illustreted in text, both expressions use constructors, not assignment operators, so parameter rhs is not involved in this context. </span>
</pre></div>
</div>
</div>

<div id="outline-container-orgb0f5677" class="outline-2">
<h2 id="orgb0f5677">Exercise 13.53</h2>
<div class="outline-text-2" id="text-orgb0f5677">
<div class="highlight"><pre><span></span><span class="c1">// See HasPtr.h.</span>
<span class="c1">// The efficiency of copy-assgnment operator of HasPtr class type is not good enough, for that there is a copy constructor called when argument passed in, and the exchanging of value within function body may be unnecessary.</span>
<span class="c1">// The new move-assignment operator takes control of the resources owned by another source object, and makes sure that object in a valid and destruction-safe state.</span>
<span class="c1">// The copy-swap operator implements assignment by value exchanging, finally the data member ps points to a new allocated string, which is a copy of string object pointed by right operand's data member ps, the right operand stays unchanged.</span>
</pre></div>

<p>
<a href="#orgb1500a3">HasPtr.h</a>
</p>
</div>
</div>

<div id="outline-container-org040c8e0" class="outline-2">
<h2 id="org040c8e0">Exercise 13.54</h2>
<div class="outline-text-2" id="text-org040c8e0">
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">HasPtr</span> <span class="n">h</span><span class="p">(</span><span class="s">"helloworld"</span><span class="p">);</span>
  <span class="n">HasPtr</span> <span class="n">h2</span> <span class="o">=</span> <span class="n">h</span><span class="p">;</span>
  <span class="n">HasPtr</span> <span class="n">h3</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">h2</span><span class="p">);</span>
  <span class="n">h2</span> <span class="o">=</span> <span class="n">h</span><span class="p">;</span>
  <span class="n">h2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">h3</span><span class="p">);</span>
  <span class="c1">// if the original copy-assignment operator stay unchanged</span>
  <span class="c1">// compiler warns:</span>
  <span class="c1">// ambiguous overload for 'operator=' (operand types are 'HasPtr'</span>
  <span class="c1">// and 'std::remove_reference&lt;HasPtr&amp;&gt;::type {aka HasPtr}')</span>
<span class="p">}</span>
</pre></div>
</div>
</div>

<div id="outline-container-org7d61f0f" class="outline-2">
<h2 id="org7d61f0f">Exercise 13.55</h2>
<div class="outline-text-2" id="text-org7d61f0f">
<div class="highlight"><pre><span></span><span class="c1">// See StrBlob.h.</span>
</pre></div>

<p>
<a href="#orgb2c00e2">StrBlob.h</a>
</p>
</div>
</div>

<div id="outline-container-org6e2001f" class="outline-2">
<h2 id="org6e2001f">Exercise 13.56</h2>
<div class="outline-text-2" id="text-org6e2001f">
<div class="highlight"><pre><span></span><span class="c1">///////////////////////////////</span>
<span class="c1">// Foo Foo::sorted() const &amp; //</span>
<span class="c1">// {			     //</span>
<span class="c1">//   Foo ret(*this);	     //</span>
<span class="c1">//   return ret.sorted();    //</span>
<span class="c1">// }			     //</span>
<span class="c1">///////////////////////////////</span>
<span class="c1">// The return statement causes infinite recursively calling, exceeds the max stack depth.</span>
</pre></div>
</div>
</div>

<div id="outline-container-org1163188" class="outline-2">
<h2 id="org1163188">Exercise 13.57</h2>
<div class="outline-text-2" id="text-org1163188">
<div class="highlight"><pre><span></span><span class="c1">// Passed, got the desired result.</span>
</pre></div>
</div>
</div>

<div id="outline-container-org7067af7" class="outline-2">
<h2 id="org7067af7">Exercise 13.58</h2>
<div class="outline-text-2" id="text-org7067af7">
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Foo</span> <span class="n">sorted</span><span class="p">()</span> <span class="o">&amp;&amp;</span><span class="p">;</span>
  <span class="n">Foo</span> <span class="nf">sorted</span><span class="p">()</span> <span class="k">const</span> <span class="o">&amp;</span><span class="p">;</span>
<span class="k">private</span><span class="o">:</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">// Foo Foo::sorted() const &amp;</span>
<span class="c1">// {</span>
<span class="c1">//   cout &lt;&lt; "Foo Foo::sorted() const &amp;" &lt;&lt; endl;</span>
<span class="c1">//   Foo ret(*this);</span>
<span class="c1">//   return ret.sorted();		// segment fault </span>
<span class="c1">// }</span>
<span class="n">Foo</span> <span class="n">Foo</span><span class="o">::</span><span class="n">sorted</span><span class="p">()</span> <span class="k">const</span> <span class="o">&amp;</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">Foo</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">).</span><span class="n">sorted</span><span class="p">();</span>	<span class="c1">// passed </span>
<span class="p">}</span>
<span class="n">Foo</span> <span class="n">Foo</span><span class="o">::</span><span class="n">sorted</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
<span class="p">{</span>
  <span class="n">sort</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">data</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">Foo</span> <span class="n">f</span><span class="p">;</span>
  <span class="n">f</span><span class="p">.</span><span class="n">sorted</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
            
        
        <div id="disqus_thread"></div>
        <script>
        var disqus_shortname ="https-zero4drift-github-io",
            disqus_url="https://zero4drift.github.io/posts/Cpp-Primer-5th-Exercises-Chapter-13/",
        disqus_title="Cpp-Primer-5th-Exercises-Chapter-13",
        disqus_identifier="cache/posts/Cpp-Primer-5th-Exercises-Chapter-13.html",
        disqus_config = function () {
            this.language = "en";
        };
        (function() {
            var dsq = document.createElement('script'); dsq.async = true;
            dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
</noscript>
    <a href="https://disqus.com" class="dsq-brlink" rel="nofollow">Comments powered by <span class="logo-disqus">Disqus</span></a>


        
    


        </div>
    </div>

    
    <footer><div class="container">
            <div class="social">



                <div class="social-entry">
                    <a href="../../rss.xml" target="_blank">
                        <i class="fa fa-rss"></i> 
                    </a>
                </div>
            </div>
                <div class="copyright">
                    Contents © 2018         <a href="mailto:fang0052@e.ntu.edu.sg">zero4drift</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         
                    
                </div>
           
        </div>
    </footer><script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?06e0ade16d98033ac1aad78106d873c8";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script src="../../assets/js/all-nocdn.js" type="text/javascript"></script>
</body>
</html>
